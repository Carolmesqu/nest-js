Banco: docker-compose up -d
Projeto: npm run start

Criar um projeto com Nest é bem fácil, o próprio framework disponibiliza uma 
ferramenta de linha de comando (CLI) para que não tenhamos muito trabalho 
instalando e configurando vários pacotes diferentes usando o NPM.

Para criar um novo projeto Nest, tudo que precisamos fazer é usar o comando 
abaixo no terminal, em um diretório de sua preferência, informando o nome 
do projeto logo após o new. No nosso caso, o projeto se chamará loja.

npx @nestjs/cli new loja

Este comando pode demorar um pouco dependendo da sua conexão de internet, 
isso por que ele vai criar uma nova pasta com o mesmo nome do projeto, 
criar também o package.json que o Node precisa para gerenciar as 
dependências do projeto e baixar todas as dependências necessárias 
para a execução do Nest.

Após este processo finalizar, podemos entrar na pasta do projeto e usar 
o comando npm start para iniciar o projeto. Porém, como estamos em 
desenvolvimento, é mais interessante que usemos o servidor de desenvolvimento, 
já que este observa as mudanças que faremos nos arquivos e automaticamente 
reinicia o servidor para que possamos testar nossas mudanças no navegador 
ou no postman.

Para iniciar o servidor de desenvolvimento, basta usar o comando 
npm run start:dev. Lembre-se de parar o servidor anterior caso tenha iniciado. 
Você pode fazer isso com o atalho de teclado CTRL + C no terminal.

O Servidor estará ouvindo requisições na porta 3000, então podemos acessar 
http://localhost:3000 e veremos uma mensagem de Hello World. Experimente 
brincar um pouco com o Nest modificando esta mensagem que está no 
App.service.ts.

---------------------------------------------------------------------------------

Compreender o que é o Nest, e assim saber algumas de suas características.
A usar a CLI do Nest, para criar projetos.
Usar o npm para iniciar o servidor de do Nest para receber requisições.

---------------------------------------------------------------------------------

O Time do Alex está usando Nest em seu projeto para salvar os produtos de uma 
compra. O código do controller que recebe os dados é semelhante ao que se 
encontra abaixo. Porém, os dados não estão sendo salvos corretamente. 
Analise abaixo:

@Controller('/compras')
export class CompraController {
    construtor(private compraRepository: CompraRepository){}

    @Post()
    async registra(produtos: Produto[]) {
         this.compraRepository.salva(produtos);
    }
}

Assinale a alternativa que justifica o motivo dos dados não estarem sendo salvos 
corretamente:

R: O parâmetro produtos no método registra, não tem nenhum decorator indicando 
de onde o Nest deve buscar o valor, o correto seria decorar esse parâmetro 
com @Body.
Sem o decorator @Body, o Nest não sabe de onde buscar o valor desejado para o 
parâmetro do método. Neste caso, estamos pedindo para o Nest popular o parâmetro 
produtos com o que vier no body da requisição.

---------------------------------------------------------------------------------

O Nest possui outros decorators para capturar dados a partir de uma requisição, 
inclusive o @Body tem outros usos. Se precisarmos, por exemplo, capturar só uma 
parte de um objeto que foi enviado no body podemos passar o nome da chave desta 
parte do objeto e o Nest captura apenas este valor. Vejamos o objeto abaixo:

{
    numeroPedido: 23123
    produtos: [
        {
          nome: "camiseta nerd 2077",
          preco: 24.90
        }
    ]
}

Se quiséssemos capturar apenas a lista de produtos, poderíamos fazer 
@Body('produtos') e o Nest nos daria apenas os produtos ignorando o restante dos 
valores no objeto. Temos outros dois decoratos que se comportam de forma parecida 
com o @Body. Eles são o @Query e o @Param, o primeiro lida com query parameters 
e o segundo com parâmetros dinâmicos na URL. Veremos mais sobre estes outros 
durante nossos estudos.

---------------------------------------------------------------------------------

O Nest, em toda a sua documentação, estrutura seus exemplos sempre pensando em 
módulos. É uma ideia muito inspirada na arquitetura do Angular, inclusive, a 
estrutura e configurações são quase idênticas, com alguns ajustes.

A documentação às vezes deixa a entender que é uma boa ideia seguir pelo caminho 
de feature modules, onde cada feature do seu projeto deve ser isolada em um 
módulo; porém, pode ser uma estrutura de granularidade muito pequena - e isso 
pode variar de projeto para projeto.

No geral, acredito que cada módulo deve ser pensado de forma isolada, com poucas 
dependências, a fim de que se um dia precisarmos separar módulos dessa aplicação 
em aplicações diferentes, seguindo o caminho dos microserviços, possamos ter a 
facilidade de fazer isso com pouco esforço. Então, daí, temos a ideia de 
monólitos modulares, onde teremos uma aplicação monolítica, porém estruturada 
em partes com bom encapsulamento e baixo acoplamento.

Estruturar aplicações é uma arte da engenharia que sempre está em evolução. 
Então, não se apegue muito a estruturas, pois no geral as recomendações de cada 
framework são boas. Assim, segui-las no início é muito útil para aprender como 
cada coisa funciona, mas cada projeto tem suas necessidades. Decida com seu 
time o melhor caminho!

---------------------------------------------------------------------------------

A Injeção de dependências é um mecanismo que faz muito uso dos conceitos do 
SOLID, principalmente do princípio D, de Dependency Inversion, em que uma classe 
deveria depender de uma interface comum, sendo que qualquer objeto que implemente
essa interface é um objeto aceitável para uso na classe onde ele foi inserido.

Nosso controller, por exemplo, recebe um objeto específico de repositório, 
e isso nos dá pouca flexibilidade. Porém, se usássemos uma interface como 
dependência para nosso controller, poderíamos em tempo de desenvolvimento 
usar um repositório que armazena os dados na memória, como já fizemos. Mas, 
em teste ou em produção, poderíamos usar um outro repositório que salva de 
fato os dados em um banco de dados como o MySQL.

Vale lembrar que para que o Nest consiga injetar uma dependência de uma classe, 
a classe que será injetada deve estar presente no módulo como um provider e 
decorada com o @Injectable.

SOLID é um assunto que sempre dá para se estender nas discussões, há livros 
e mais livros que explicam e exemplificam cada um dos conceitos. Ficou curioso? 
O Livro do Alexandre Aquiles da Casa do Código pode esclarecer muito sobre o 
assunto. O Livro do Maurício Aniche também. Confira as referências deles a seguir:

Orientação a Objetos e SOLID para Ninjas: Projetando classes flexíveis
Desbravando SOLID: Práticas avançadas para códigos de qualidade em Java moderno
PS: Ambos os livros usam Java em seus exemplos, mas ainda é uma boa leitura.

---------------------------------------------------------------------------------

Antes de começar a fazer todo o cadastro de usuário, certifique-se que apagou os 
arquivos que não vamos precisar para o nosso projeto. São estes: app.service.ts, 
o app.e2e-spec.ts e app.controller.ts que estão dentro de src. Também apague as 
referências para estes arquivos dentro do app.module.ts. O app.module.ts deve 
ficar como o código abaixo:

import { Module } from '@nestjs/common';

@Module({
  imports: [],
})
export class AppModule {}COPIAR CÓDIGO
Depois disso, estamos prontos para iniciar! Sabemos que para tornar possível 
cadastrar um usuário, precisamos de uma rota que possa receber os dados do 
usuário via POST. Para isso, precisamos de um controller.

Vamos criar uma nova pasta dentro de src para agruparmos códigos que lidam 
com o usuário, o nome dessa pasta será usuario e dentro dela, criaremos dois 
arquivos, estes são: usuario.controller.ts e usuario.module.ts. O controller 
terá um código semelhante a este:

import { Body, Controller, Post } from "@nestjs/common";

@Controller('/usuarios')
export class UsuarioController {

    @Post()
    async criaUsuario(@Body() dadosDoUsuario) {
                return dadosDoUsuario;
    }

}COPIAR CÓDIGO
O módulo de usuário por outro lado, será apenas uma classe com o decorator 
@Module() adicionando nosso controller na configuração de controllers do
 módulo.

import { Module } from "@nestjs/common";
import { UsuarioController } from "./usuario.controller";

@Module({
    controllers: [UsuarioController],
})
export class UsuarioModule {}COPIAR CÓDIGO
Com isso, estamos quase prontos para receber dados via POST no endereço 
localhost:3000/usuarios. O último ponto é adicionar nosso módulo de usuário 
na árvore de módulos da aplicação Nest, como ilustra o código abaixo do 
arquivo app.module.ts:

import { Module } from '@nestjs/common';
import { UsuarioModule } from './usuario/usuario.module';

@Module({
  imports: [UsuarioModule],
})
export class AppModule {}COPIAR CÓDIGO
Ainda precisamos, de alguma forma, salvar os dados do usuário em nosso 
banco em memória. Para isso, criaremos nosso repositório de usuários, o nome 
do arquivo será usuario.repository.ts e ficará dentro da mesma pasta do 
controller de usuário:

import { Injectable } from "@nestjs/common";

@Injectable()
export class UsuarioRepository {
    private usuarios = [];

    async salvar(usuario) {
        this.usuarios.push(usuario);
    }
}COPIAR CÓDIGO
Também precisamos adicionar o nosso repositório dentro do módulo de usuário, 
para que o Nest consiga injetar objetos dessa classe em nosso controller:

import { Module } from "@nestjs/common";
import { UsuarioController } from "./usuario.controller";
import { UsuarioRepository } from "./usuario.repository";

@Module({
    controllers: [UsuarioController],
    providers: [UsuarioRepository]
})
export class UsuarioModule {}COPIAR CÓDIGO
Agora, em nosso controller, podemos receber o repositório através do 
construtor e usar o método salvar ao receber os dados do usuário.

@Post()
async criaUsuario(@Body() dadosDoUsuario) {
    this.usuarioRepository.salvar(dadosDoUsuario);
    return dadosDoUsuario;
}COPIAR CÓDIGO
Ótimo, já podemos cadastrar usuários, agora precisamos listá-los. 
Como fazer isso?

As mudanças que precisamos fazer são mínimas. Primeiro, precisamos 
devolver a lista de usuários que foram salvos no nosso usuario.repository.ts 
com um método novo que chamaremos de listar:

async listar() {
    return this.usuarios;
}COPIAR CÓDIGO
E em nosso usuario.controller.ts faremos um novo método que responde por GET 
e usa o método listar para devolver a lista de usuários que é retornada pelo 
repositório.

@Get()
    async listUsuarios() {
    return this.usuarioRepository.listar();
}COPIAR CÓDIGO
Agora podemos tanto cadastrar, quanto listar usuários!

---------------------------------------------------------------------------------

Para o cadastro de produtos, teremos a mesma estrutura de arquivos e a lógica 
será praticamente idêntica. Faremos da forma mais simples possível e vamos 
ajustando conforme for necessário. Dito isso, replique a estrutura que usamos 
para cadastrar usuários fazendo as devidas alterações para funcionar para produtos.

Criaremos uma nova pasta chamada produto dentro de src e nela criaremos os 
arquivos produto.controller.ts, produto.repository.ts e produto.module.ts.

Teremos a rota que responde via GET e via POST. Quando recebermos um GET, 
listaremos os produtos cadastrados, quando recebermos um POST, iremos capturar 
os dados que vierem no corpo de requisição e salvar estes dados no repositório de 
produtos.

O JSON abaixo é um exemplo que apresenta todos os dados necessários para 
cadastrar um produto:

{
    "nome": "Figura de ação Marvel Homem Aranha Olympus Homem Aranha E6358 de Hasbro Classic",
    "valor": 70.0,
    "quantidadeDisponivel": 10,
    "descricao": "Produto novo, bem acabado, alegria para colecionadores",
    "caracteristicas": [{
        "nome": "Fabricante",
        "descricao": "Iron Studios"
    },{
        "nome": "material",
        "descricao": "Plástico"
    }],
    "imagens": [{
        "url": "https://i.imgur.com/dwDZICq.jpg",
        "descricao": "Imagem do Homem Aranha"
    }],
    "categoria": "Colecionáveis",
    "dataCriacao": "2022-10-12T14:22:53.496Z",
    "dataAtualizacao": "2022-10-12T14:22:53.496Z"
}

Note que temos o nome do produto, valor, quantidade disponível, descrição, 
características, imagens, categoria e datas de criação e atualização 
do produto.

Não se preocupe ainda com a validação destas informações ou mesmo com a 
associação de quem foi o usuário que cadastrou um produto específico. 
Teremos uma atividade específica para isso.

---------------------------------------------------------------------------------

Criar rotas que respondem aos métodos GET e POST do HTTP usando os decorators 
@Get, @Post em conjunto com o @Controller.
Capturar dados que são enviados no corpo da requisição POST com o decorator @Body.
Criar módulos no Nest.
Usar a injeção de dependências com o @Injectable e configurando corretamente 
as classes no módulo.

---------------------------------------------------------------------------------

A Juliana, que está entrando no time e projeto em que você está desenvolvendo 
com NestJS, precisa escrever uma validação que verifica se um valor número foi 
enviado para API e ela está com dúvidas de como fazer isso. Qual das alternativas 
abaixo descreve a melhor forma da Juliana fazer essa validação?

R: Criar um DTO que descreve os dados que serão recebidos pelo endpoint e 
habilitar o pipe de validação globalmente na aplicação.
O DTO faria o papel de descrever os atributos que serão recebidos pelo Controller 
e habilitar o Pipe de validação global, faz a validação acontecer automaticamente.

---------------------------------------------------------------------------------

Criar DTOs é muito comum em vários tipos de projetos independente da linguagem 
ou do framework. Muitas vezes esses objetos podem aparecer com outros sufixos 
como Request, Form.

No geral, é apenas um objeto que define a interface entre duas camadas, 
normalmente, nas bordas mais externas das aplicações, ou seja, para indicar 
os campos e tipos permitidos nas entradas da aplicação; e claro, também é 
recomendado para definir as saídas.

A sigla é um acrônimo para Data Transfer Object, que quer dizer basicamente 
um objeto de transferência de dados. Por isso, ele é um objeto que também 
pode ser usado como base para validar os dados a serem recebidos por nossa 
aplicação.

Criar DTOs pode parecer trabalhoso ou mesmo chato, mas ele desempenha um
 papel importante no conjunto de boas práticas de desenvolvimento de 
 software.

 ---------------------------------------------------------------------------------

 Para validar produtos, precisamos quebrar o problema dessa validação em partes. 
 Primeiro, vamos relembrar como é o JSON que precisamos enviar para cadastrar um produto:

{
    "nome": "Figura de ação Marvel Homem Aranha Olympus Homem Aranha E6358 de 
    Hasbro Classic",
    "valor": 70.0,
    "quantidadeDisponivel": 10,
    "descricao": "Produto novo, bem acabado, alegria para colecionadores",
    "caracteristicas": [{
        "nome": "Fabricante",
        "descricao": "Iron Studios"
    },{
        "nome": "material",
        "descricao": "Plástico"
    }],
    "imagens": [{
        "url": "https://i.imgur.com/dwDZICq.jpg",
        "descricao": "Imagem do Homem Aranha"
    }],
    "categoria": "Colecionáveis",
    "dataCriacao": "2022-10-12T14:22:53.496Z",
    "dataAtualizacao": "2022-10-12T14:22:53.496Z"
}COPIAR CÓDIGO
Claramente, podemos quebrar esse JSON em algumas partes. Podemos observar que 
qualquer chave do JSON que tem uma lista como valor pode ser representada como uma 
classe diferente. Um exemplo seria as características de um produto que possuem, por 
enquanto, o nome do fabricante e o material do qual é feito o produto. 
Poderíamos separar isso em uma classe:

export class CaracteristicaProdutoDTO {
  nome: string;
  descricao: string;
}COPIAR CÓDIGO
A mesma ideia é válida para a validação das Imagens do produto. Isso nos geraria 
uma classe CriaProdutoDTO parecida com a que se encontra abaixo:

export class CriaProdutoDTO {
  nome: string;
  valor: number;
  quantidade: number;
  descricao: string;
  caracteristicas: CaracteristicaProdutoDTO[];
  imagens: ImagemProdutoDTO[];
  categoria: string;
}COPIAR CÓDIGO
A pergunta que fica é: como fazer o pipe validar um atributo que na verdade é 
uma lista de objetos de outra classe que também possui suas próprias validações? 
O class-validator nos ajuda nisso também.

Primeiro, precisamos validar que deve ser uma lista, ou melhor, um array. Para 
isso temos o decorator @IsArray(). Segundo, precisamos dizer para o class-validator
 que ele deve validar o objeto que está sendo referenciado pelo atributo, ou seja, 
 precisa fazer a validação aninhada ao atributo validado, para isso usaremos o 
 decorator @ValidateNested().

E, por último, precisamos informar o tipo do objeto ao qual o atributo faz 
referência, para transformar o objeto do atributo no tipo correto e para isso 
usaremos o decorator @Type() que por parâmetro espera uma função que retorne o 
tipo ao que o atributo está se referindo.

Juntando tudo, teremos uma validação que segue o seguinte formato para as 
características do produto:

@ValidateNested()
@IsArray() 
@Type(() => CaracteristicaProdutoDTO)
caracteristicas: CaracteristicaProdutoDTO[];COPIAR CÓDIGO
Com isso em mente, crie a validação de criação de produtos. Elas precisam 
atender aos critérios abaixo:

O nome do produto não pode ser vazio;
O valor do produto precisa ser um número positivo (não pode ser zero) e ter 
até duas casas decimais;
A quantidade precisa ser um número igual ou maior que zero;
A descrição não pode ser vazia ou maior que 1000 caracteres;
A lista de características do produto precisa ter pelo menos 3 itens;
A lista de imagens do produto precisa ter pelo menos 1 item;
A categoria do produto não pode ser vazia.
Algumas dessas validações não exploramos aqui, mas estão todas descritas na 
documentação do class-validator que você pode acessar neste link.

---------------------------------------------------------------------------------

O que são Pipes e seus casos de uso;
Como habilitar o pipe de validação global do Nest;
Como validar dados de requests com DTOs usando decorators do 
class-validator e class-transformer;
Validações mais complexas com objetos aninhados e arrays.


---------------------------------------------------------------------------------

O Ronaldo estava discutindo com seus colegas de trabalho sobre validações 
síncronas e assíncronas e ao ser indagado sobre quais os limites das validações 
síncronas, o mesmo respondeu de uma forma que gerou mais dúvidas do que sanou. 
Das alternativas abaixo, qual delas descreve bem os limites da validação síncrona:

R: É uma boa prática sempre usar uma validação assíncrona quando não conseguimos 
validar determinado dado de forma isolada. Se precisarmos consultar um terceiro, 
por exemplo, devemos fazer isso de forma assíncrona para não gerar uma trava nos 
processos onde as validações são enfileiradas por estarem segurando requisições HTTP.
As requisições HTTP ainda serão enfileiradas, afinal as respostas precisam ser 
devolvidas para o cliente, porém, o Node sabe lidar com isso e gerência os recursos 
para conseguir responder bem mesmo em grandes volumes de requisição, mas é nosso 
papel saber usar estes recursos.

---------------------------------------------------------------------------------

Estudamos vários decorators do Nest até o momento, mas você sabia que um decorator 
é apenas uma função como qualquer outra? Claro, dependendo do tipo de decorator 
que estamos criando, ele pode ser mais ou menos complexo de entender e escrever.

Isso porque temos decorators que podem ser usados a nível de classe como o 
@Controller do Nest. Vimos também os de nível de método como o @Get e outros 
decorators de HTTP que o Nest nos provê e temos também o decorator de propriedade 
que são todos que usamos em nossos validadores.

Quer saber como criar seus próprios decorators do zero? Aqui na Alura temos um 
curso de Typescript que ensina isso e muito mais, é um curso mais avançado, 
então verifique se tem os pré-requisitos certinhos:

---------------------------------------------------------------------------------

Validar que um e-mail já foi usado por outro usuário da nossa lógica precisa 
ser feito de forma assíncrona, visto que precisamos ir até o banco de dados 
ou mesmo outro serviço e esperar uma resposta.

Dito isso, crie um novo provider, que decorado com 
@ValidatorConstraint({ async: true }), implemente a interface 
ValidatorConstraintInterface. Este provider também deve receber como dependência 
no construtor o repositório de usuários, afinal, é o repositório que faz interação 
com o banco de dados.

A interface ValidatorConstraintInterface no seu método validate, espera que 
retornemos um valor booleano que indique se a validação foi um sucesso ou não. 
Se retornarmos o valor false, o erro de validação deve ser apresentado.

Para criar o decorator que executa a validação personalizada que acabamos de 
descrever, precisamos criar uma função. O nome desta função será o nome do decorator. 
E, como parâmetro, essa função deve receber um objeto do tipo ValidationOptions, 
interface importada do pacote class-validator.

Nossa função decorator deve retornar como resultado uma nova função que tem 
como parâmetros o objeto a ser validado e o nome da propriedade que será validada.

Esta segunda função deve executar o registro deste decorator no class-validator 

por meio do uso da função registerDecorator que recebe como argumento um objeto, 
informando o target alvo da validação, a propriedade a ser validada, as opções de 
validação, as constraints e por último o validator (classe que já escrevemos antes).

Validações assíncronas normalmente são mais complexas, envolvem mais partes da aplicação. 
Caso precise de uma implementação de referência, você pode consultar este commit.

---------------------------------------------------------------------------------

Criar uma validação assíncrona para aplicar validações complexas;
Criar um decorator para aplicar validações customizadas;
Usar o gestor de dependência do Nest para injetar objetos nas validações customizadas.

---------------------------------------------------------------------------------

Para atualizar um recurso em uma API Restful, temos dois métodos HTTP disponíveis, 
eles são o PUT e o PATCH. Qual usar?

De acordo com a especificação, o método PATCH deve ser utilizado para atualizar 
um recurso de forma parcial, ou seja, sem precisar informar todos os dados. 
Vejamos o exemplo abaixo de um recurso que representa um curso na Alura:

{
    "nome": "JavaScript Avançado",
    "nivel": "Avançado",
    "cargaHorariaEmHoras": 8
}COPIAR CÓDIGO
Para atualizar o nome apenas, usando o método PATCH, deveríamos 
enviar apenas o dado a ser atualizado, neste caso:

{
    "nome": "JavaScript Avançado: Programando de forma funcional"
}COPIAR CÓDIGO
Por outro lado, para atualizar o mesmo objeto usando o método PUT, 
deveríamos enviar o objeto completo, inclusive com os dados que não 
vamos atualizar. Dessa forma, para atualizar o nome do curso, o corpo 
da requisição seria o exemplificado abaixo:

{
"nome": "JavaScript Avançado: Programando de forma funcional",
    "nivel": "Avançado",
    "cargaHorariaEmHoras": 8
}COPIAR CÓDIGO
Para estarmos 100% alinhados com a especificação, deveríamos implementar 
as duas formas, muitas APIs implementam, outras não. Outras permitem você 
atualizar um recurso de forma parcial usando o PUT. Essa variação não é 
um problema, pois os times que implementaram essas APIs devem ter decidido 
isso seguindo algum critério.

---------------------------------------------------------------------------------

Para finalizar nosso CRUD, precisamos permitir a atualização dos dados de um 
usuário e também a remoção desse usuário da nossa aplicação. Antes disso, vamos 
fazer dois pequenos incrementos na nossa aplicação.

O primeiro desses incrementos é criar uma representação real do que é um usuário 
na nossa aplicação, a entidade usuário. Essa classe possui como atributos o nome, 
email, senha e id do usuário. Por fim, devemos usar essa entidade nos lugares onde 
lidamos com o usuário, ou seja, no repositório. A inicialização do nosso array de 
usuários deve ficar como se encontra abaixo:

private usuarios: UsuarioEntity[] = [];COPIAR CÓDIGO
Há mais lugares onde podemos usar nossa entidade de usuário como no controller, 
ao criar um usuário novo a partir do DTO de criação de usuário.

O segundo incremento é criar um novo DTO responsável por representar um usuário 
em nossa listagem; este deve apenas exibir o id e o nome do usuário. E atenção: 
já devemos refatorar nossa listagem de usuários para usar este novo DTO.

Para atualizar um usuário, precisamos criar um novo DTO, muito parecido com o 
de criação de usuário, porém, com todos os campos opcionais. Afinal, não sabemos 
quais campos o usuário irá atualizar. Contudo, caso o campo seja enviado, ele 
precisa passar pelas mesmas validações de criação de um usuário novo, ou seja, 
o e-mail não pode ter sido usado por outro usuário, etc.

Para validar um campo de forma opcional, podemos usar o decorator @IsOptional 
do class-validator como no exemplo abaixo:

@MinLength(6, { message: 'A senha precisa ter pelo menos 6 caracteres' })
@IsOptional()
senha: string;COPIAR CÓDIGO
Além disso, precisamos ter o cuidado de não permitir que o usuário atualize o 
próprio id no repositório, visto que vamos receber como parâmetro um objeto 
parcial de um usuário no método atualiza:

async atualiza(id: string, dadosDeAtualizacao: Partial<UsuarioEntity>) {}
Para remover um usuário, o processo é um pouco mais simples: precisamos 
apenas do ID do usuário enviado como parâmetro na URL usando o método DELETE.

 @Delete('/:id')
 async removeUsuario(@Param('id') id: string) {}COPIAR CÓDIGO
Um ponto de atenção importante é que tanto na atualização dos dados do usuário, 
 na remoção, precisamos retornar como resposta um objeto com uma mensagem 
 indicando se o usuário foi removido ou atualizado, assim como os dados desse 
 usuário, algo semelhante ao que se encontra abaixo:

return {
   usuario: usuarioRemovido,
  messagem: 'usuário removido com suceso',
};

---------------------------------------------------------------------------------

Chegou o momento de replicar tudo que fizemos para finalizar o CRUD de usuários, 
para produtos. Segue uma lista simples com tudo que precisamos fazer:

Criar a entidade de produto, essa será idêntica ao CriaProdutoDTO que já 
escrevemos antes; porém, com um atributo extra, o ID do produto que será um UUID;
Usar a entidade de produto nos métodos do repositório de produtos;
Ajustar o código do controller de produtos para que o mesmo crie um objeto da entidade 
produto ao tentar salvar um produto no repositório;
Criar o DTO de atualização de produto; este é idêntico ao de criação de produto, porém, 
com todos os campos opcionais com exceção do id do produto e o id do usuário;
Escrever o método atualiza no repositório de produto, no qual, dado um id e os dados de 
atualização de um produto, o método atualiza os valores que foram recebidos, filtrando o id
 do produto e do usuário, sendo que estes valores não podem ser atualizados;
Criar o método atualiza no controller de produto que responde ao método HTTP Put, que recebe 
como parâmetro de URL o id do produto a ser atualizado e como corpo da requisição os dados do 
produto com as validações já presentes no DTO. E assim haver o retorno ao final de uma mensagem 
que informa que o produto foi atualizado com sucesso, assim como os dados do produto;
Escrever o método remove no repositório, no qual, dado um id, busca o produto e o remove da 
lista de produtos, retornando ao final os dados do produto removido;
Escrever o método remove no controller de produtos que recebe como parâmetro de URL o id do 
produto e executa a remoção do produto, e retorna como resposta uma mensagem informando que o 
produto foi removido, assim como os dados do produto. Este método no controller deve responder
ao método DELETE do HTTP.

---------------------------------------------------------------------------------

 Um ponto importante na evolução de APIs Restful é como lidamos com a evolução 
 dessas APIs. Uma API precisa se manter estável quando em produção com clientes 
 fazendo uso de seus recursos. Diante disso, não é recomendável que simplesmente 
 removamos valores ou alteremos como determinado recurso funciona, pois os clientes 
 dessa API podem parar de funcionar de forma inesperada.

Claro, se é uma API privada, onde as alterações são negociadas entre as partes, 
este é um problema mais fácil de lidar. Mas em APIs públicas, como a do GitHub e 
outros serviços, essa é uma problemática para se ter cuidado.

Por isso, existem maneiras de lidar com essa evolução. Uma delas é o versionamento 
da API. Em casos em que determinado endpoint precise de mudanças, cria-se uma versão 
nova daquele mesmo endpoint onde essas mudanças serão aplicadas.

Este versionamento pode acontecer de algumas formas, a mais comum delas é a adição de 
um sub-caminho para o recurso, que especifica que versão está sendo usada daquela API. 
O exemplo abaixo ilustra melhor:

https://api.alura.com.br/v2/cursosCOPIAR CÓDIGO
O v2 presente na URL do endpoint indica a versão da API que estamos utilizando. Outra 
forma é usando query parameters, enviando também na URL, qual a versão da API que estamos 
usando:

https://api.alura.com.br/cursos?v=2COPIAR CÓDIGO
Por último, podemos usar cabeçalhos do HTTP para indicar para o servidor qual versão 
queremos usar da API. Normalmente, o cabeçalho usado é o Accept, mas pode ser um outro. 
O NestJS já possui um mecanismo que lida com o versionamento das APIs, facilitando a 
gestão desses endpoints.

Caso queira saber mais sobre as possibilidades de versionamento da API com Nestjs, a 
documentação possui uma página para explicar as formas suportadas por ele. Você pode 
ler mais neste link.

O que precisa ficar claro também é que conforme uma API evolui e publica mais versões 
de seus endpoints, mais complexo fica gerenciar a API em si. Cada endpoint evolui de 
forma independente, o que pode gerar situações onde um endpoint nunca precisou mudar, 
por isso, sempre esteve na sua versão original e outros endpoints que podem ter 3 ou 
4 versões diferentes.

---------------------------------------------------------------------------------

Em APIs Restful, você pode ter endpoints isolados, ou seja, lidam com as operações 
de CRUD de forma isolada sob um recurso só e endpoints que lidam com relacionamentos 
ou agregações.

Nos endpoints que lidam com relacionamentos/agregações, dependendo do tipo de 
relacionamento, a recomendação geral é que esse relacionamento seja expresso também nas 
URLs dos recursos.

Vejamos nosso exemplo da loja: Um usuário possui produtos. Sendo assim, os produtos 
da loja estão com um relacionamento forte com seus usuários. De fato, o usuário cria e 
remove produtos como bem entender. Sendo assim, a recomendação geral é que o CRUD de 
produtos tivesse endpoints relativos ao de usuários. O que isso quer dizer na prática? 
A URL a seguir demonstra a relação entre produtos e usuário:

http://localhost:3000/usuarios/1234/produtosCOPIAR CÓDIGO
O número 1234 na URL representa o usuário com aquele identificador. O /produtos logo 
após o identificador de usuário, representa o endpoint raiz de operações do CRUD para 
produtos daquele usuário. Considerando isso, teríamos o seguinte esquema de CRUD para 
produtos:

POST http://localhost:3000/usuarios/1234/produtos, para criar um produto;
GET http://localhost:3000/usuarios/1234/produtos, para listar todos os produtos;
PUT/PATCH http://localhost:3000/usuarios/1234/produtos/4321, para atualizar um produto;
DELETE http://localhost:3000/usuarios/1234/produtos, para remover um produto.
Durante nossas aulas, não seguimos este padrão para simplificar a construção geral da 
nossa loja. É importante ter isso em mente: não seguir uma recomendação ou um padrão 
precisa ser uma escolha consciente sobre os impactos dessa escolha.

---------------------------------------------------------------------------------

Usar o @PUT para atualizar um recurso na API.
Usar o @Delete para remover um recurso da API.
Criamos entidades para isolar objetos importantes do nosso contexto de negócio.
Usar o padrão DTO para isolar objetos de entrada e saída da nossa API.
Usar o @IsOptional para validar dados caso eles sejam enviados no corpo da requisição.

---------------------------------------------------------------------------------

Preparando o ambiente: configurando o Datasource

Para configurar o Datasource, o pré-requisito é apenas ter o typeORM e o 
módulo @nestjs/config já configurados. Com isso, basta seguir as instruções 
abaixo:

Na pasta src, crie uma pasta config e, dentro dela, crie um arquivo com o 
nome postgres.config.service.ts. Um detalhe interessante aqui é o seguinte: 
caso queira trabalhar com outro banco, é legal que o arquivo tenha o nome 
respectivo ao banco e/ou db.config.service.ts, que seria um nome genérico.

Feito isso, basta colar o conteúdo abaixo no arquivo criado anteriormente:

    import { Injectable } from '@nestjs/common';
    import { ConfigService } from '@nestjs/config';
    import { TypeOrmModuleOptions, TypeOrmOptionsFactory } from 
    '@nestjs/typeorm';
    
    @Injectable()
    export class PostgresConfigService implements TypeOrmOptionsFactory {
    
      constructor(private configService: ConfigService) {}
    
      createTypeOrmOptions(): TypeOrmModuleOptions {
        return {
          type: 'postgres',
          host: this.configService.get<string>('DB_HOST'),
          port: this.configService.get<number>('DB_PORT'),
          username: this.configService.get<string>('DB_USERNAME'),
          password: this.configService.get<string>('DB_PASSWORD'),
          database: this.configService.get<string>('DB_NAME'),
          entities: [],
          synchronize: true,
        };
      }
    }

Agora, precisamos que você instale a lib para conectar ao seu banco de 
dados. No curso, utilizamos o postgres, portanto, vamos adicioná-lo 
ao nosso projeto com o comando npm install pg.

    Caso queira utilizar outro banco, basta instalar o conector 
    relativo.

Na sequência, basta adicionar nos imports do arquivo app.module.ts o 
seguinte código:

   TypeOrmModule.forRootAsync({
     useClass: PostgresConfigService,
     inject: [PostgresConfigService]
   }),

O código acima também deve ser adicionado nos devidos imports 
relacionados - o nome da classe vai depender do nome do seu arquivo.

E, por último, não se esqueça de adicionar as variáveis no seu 
arquivo .env.

---------------------------------------------------------------------------------

 Preparando o ambiente: configurando o pgAdmin

 

Após executar o pgAdmin utilizando o docker-compose, você deve configurá-lo. 
Para isso, basta seguir os passos abaixo:

Acesse, no seu navegador, o endereço http://localhost:8081. Você deverá 
inserir o email e a senha que estão nas variáveis de ambiente DB_ADMIN_EMAIL 
e DB_PASSWORD, respectivamente, do arquivo .env.

Na sequência, você deve clicar em “Add New Server”, definir um nome e 
clicar em “Connection”.

Em “Connection”, basta colocar as seguintes informações:

    Host: postgres
    Porta: manter a 5432
    Username: root (ou o configurado no seu arquivo .env)
    Password: root (ou o configurado no seu arquivo .env)

Feito esses passos, basta salvar e acessar o novo servidor.

Em seguida, expanda as opções do servidor que você acabou de criar (no 
canto superior esquerdo) e clique com o botão direito em Databases.

Agora, basta criar o banco; estamos usando como db_loja o nome, porém, 
fica a seu critério.

Com o banco criado, você pode rodar novamente a sua aplicação com npm 
run start. Dessa vez, agora o Nest deve se conectar sem nenhum erro 
com o Postgres!

---------------------------------------------------------------------------------

Nesta aula, conhecemos um pouco sobre Datasource e alguns padrões de acesso ao 
dado. Entendemos que o Datasource é o banco de dados em si e que por meio dos 
padrões de acesso conseguimos acessar o dado propriamente dito.

Quais afirmações estão corretas?

O sistema pode trabalhar com vários Datasources.
É possível configurar vários Datasources em uma aplicação.
Alternativa correta

O padrão Repository traz um maior desacoplamento de regras.
Com o Repository Pattern conseguimos desacoplar as regras de acesso ao dado 
da entidade.

---------------------------------------------------------------------------------

O que é um Datasource e como nossa aplicação se comunica com o banco;
Quais bancos(MySQL, PostgreSQL, SQL Server, Oracle - para citar alguns) 
estão disponíveis dentro do TypeORM;
Padrões de acesso ao dado, algo extremamente importante para acessarmos o 
dado no banco dentro das melhores práticas.

---------------------------------------------------------------------------------

No vídeo anterior, indicamos o caminho das entidades para o Data Source do 
TypeORM no arquivo postgres.config.service.ts com o seguinte código:

entities: [__dirname + '/**/*.entity{.js,.ts}'],

Contudo, um ajuste precisa ser feito. Troque o código acima para o seguinte:

entities: [__dirname + '/../**/*.entity{.js,.ts}'],

Isso porque o __dirname indica o diretório atual no qual o arquivo 
postgres.config.service.ts se encontra, que é o config. Em seguida, na 
string que estamos concatenando, a notação .. irá subir para o diretório pai, 
que é o src. Depois, com a notação /**/*.entity{.js,.ts}, as entidades serão 
buscadas dentro de qualquer pasta que esteja dentro de src, e cada entidade é 
identificada como um arquivo que termina com .entity.js ou .entity.ts.

Com isso, o TypeORM irá encontrar os arquivos de entidades com sucesso!

Atenção: para os alunos que utilizam o Windows, existe um bug presente no 
TypeORM a partir da versão 0.3.12, que tem a ver com a resolução desses caminhos.

Para prevenir esse erro quando você fizer requisições para a API, você 
pode atualizar a versão do TypeORM do projeto com o seguinte comando:

npm install typeorm@0.3.11

A discussão desse bug pode ser encontrada nesse tópico do GitHub.

Caso você não queira alterar a versão do TyepORM no seu projeto, uma solução 
alternativa é importar diretamente as entidades na lista entities.

Outra solução para não ter esse bug é utilizar o WSL, já que no ambiente 
Ubuntu não há esse problema de resolução de caminhos.

---------------------------------------------------------------------------------

Nesta aula, visitamos e aplicamos os conceitos de entidade nas nossas classes 
pré-existentes. Entendemos que entidades são o "espelho" da nossa tabela.

Sobre entidades, quais são as alternativas corretas? 

A entidade representa o mapeamento relacional da tabela no código.
Em uma entidade eu tenho todos os campos e os respectivos tipos que os 
mesmos possuem no banco de dados.

Para que o projeto consiga acessar todos os campos da tabela, necessariamente 
esses campos precisam ser referenciados na entidade.
De fato, para que minha aplicação conheça todos os campos utilizando o conceito 
de ORM, é necessário que todos estejam mapeados na entidade.

Para que o TypeORM entenda o local que as entidades estão, é preciso 
referenciar no arquivo de configuração do Datasource.
Precisamos configurar no arquivo de config o caminho da nossa pasta onde 
estão as nossas entidades.

---------------------------------------------------------------------------------

O conceito de entidades, que representam o modelo da nossa tabela 
no nosso código;
A modelar as entidades que já tínhamos para adequar ao TypeORM.

---------------------------------------------------------------------------------

Nesta aula, conseguimos criar o nosso primeiro registro. E com isso, vimos na 
prática o uso do repositório e também dos nossos campos da entidade sendo 
preenchidos e persistidos no banco - uma vez que eles representam o nosso 
modelo relacional.

Dado esse cenário, entendemos que:

Com o TypeORM a inserção é totalmente abstraída, o que significa que eu 
não preciso escrever a instrução SQL.

Isso mesmo! Nesse caso de inserção (cenário comum), não é necessário a 
escrita da query SQL. 

---------------------------------------------------------------------------------

A implementar o padrão Repository para que nossa aplicação consiga persistir e 
buscar informações das nossas tabelas no nosso banco;
A implementar na prática o Repository Pattern, padrão que já tínhamos o 
conhecimento teórico.

---------------------------------------------------------------------------------

Nesta aula, aprendemos mais sobre relacionamentos e como aplicá-los utilizando 
o TypeORM. Entendemos que existem diversos tipos de relacionamentos e a sua 
aplicabilidade depende muito do cenário negocial. No nosso caso tivemos a 
ampla utilização do tipo 1:N, visto que produtos podem ter N características 
e/ou imagens.

A partir dos seus conhecimentos sobre TypeORM e relacionamentos, indique a 
afirmação correta:

O papel do Cascade é ter um controle na hierarquia dos relacionamentos - 
caso algum registro sofra alteração e/ou seja deletado, será aplicado 
em toda a cadeia.

Exatamente isso! Com o Cascade habilitado, toda a cadeia hierárquica 
terá alterações caso o registro principal sofra uma modificação.

---------------------------------------------------------------------------------

A integrar as nossas entidades para funcionar de acordo com o modelo negocial 
definido;
A aplicar o conceito de relacionamentos nas nossas entidades, identificando 
os tipos de relacionamentos, que são: 1 para 1, 1 para N(muitos) e N para 
N - muitos para muitos.

---------------------------------------------------------------------------------

Agora que você aprendeu sobre migrações, vamos aproveitar para realizar uma 
modificação no código e praticar esse conhecimento?

Abra o arquivo src/produto/produto.entity.ts. Nele, você encontrará a seguinte 
propriedade na entidade:

  @Column({ name: 'usuario_id', length: 100, nullable: false })
  usuarioId: string;

Contudo, essa propriedade não faz mais sentido para o contexto que vamos 
modelar nosso e-commerce. Ela estaria indicando, na teoria, que um produto 
referencia o ID de um usuário. Em outras palavras, um produto poderia estar 
associado a apenas um usuário. Além disso, aqui não estamos utilizando os 
decorators de relacionamentos do TypeORM (como o @ManyToOne e @OneToMany, 
então essa relação também não está corretamente estabelecida nas nossas 
entidades.

    Dando um spoiler: o que iremos modelar a partir da próxima aula é que 
    um usuário pode possuir vários pedidos. Os pedidos, por sua vez, podem 
    possuir vários produtos, ao mesmo tempo que um produto pode fazer parte 
    de vários pedidos. Assim, não haverá relação direta entre um usuário e 
    um produto. Você verá isso em mais detalhes com a Camis!

Dessa forma, remova essas duas linhas de código de ProdutoEntity. Como isso 
resultará em uma modificação no Banco de Dados, é importante que você gere 
e rode uma nova migração que reflita essa mudança.

---------------------------------------------------------------------------------

Existem alguns casos onde as queries SQL geradas pelas migrações podem causar 
erros ao serem executadas. Um exemplo é quando tentamos adicionar, em uma tabela, 
uma nova coluna que não permite valores nulos. Por exemplo, digamos que você 
queira adicionar uma coluna endereco em UsuarioEntity:

  @Column({ name: 'endereco', length: 255, nullable: false })
  endereco: string;

    Dica: na verdade, o parâmetro nullable é false por padrão no TypeORM, 
    então mesmo que você não passe essa propriedade, a coluna será criada 
    para não permitir valores nulos.

Suponha que você já tenha registros na tabela de usuários. Se você gerar uma 
migração para a alteração acima e tentar rodá-la, você verá um erro como o 
seguinte:

QueryFailedError: column "endereco" of relation "usuarios" contains null 
values

Traduzindo: A coluna "endereco" da relação "usuarios" contém valores nulos

E faz sentido que esse erro aconteça, pois se já houver ao menos um registro 
nessa tabela, eles não conseguirão definir automaticamente um valor para essa 
coluna ao tentar adicioná-la, já que ela não permite valores nulos.

    E caso não haja registros na tabela, a migração será executada sem erros. 
    Porém, ao tentar cadastrar um novo usuário, o TypeORM lançará um erro em 
    tempo de execução da API. Nesse caso, é importante reverter a migração com 
    migration:revert para retornar o Banco de Dados ao estado que estava 
    funcionando!

Dessa forma, temos duas opções. A primeira delas é permitir valores nulos 
nesta coluna, então basta definir o valor da propriedade nullable como true:

  @Column({ name: 'endereco', length: 255, nullable: true })
  endereco: string;

Neste caso, é importante ter em mente que nem todos os usuários terão um 
endereço em um primeiro momento. E isso faz sentido, já que até este momento 
essa informação não era exigida a todos os usuários.

A outra opção é manter a coluna como não nula e definir um valor padrão para 
ela com a propriedade default:

@Column({ name: 'endereco', length: 255, nullable: false, default: 'sem_endereco' })
endereco: string;

Para esse caso em específico, não é semântico utilizar uma string 'sem_endereco', 
então a primeira opção faz mais sentido. Contudo, há casos onde definir um valor 
padrão faz mais sentido do que permitir valores nulos, como o status de um pedido.

Ao escolher uma dessas soluções, você poderá gerar uma nova migração de acordo e 
executá-la. Caso você tenha um arquivo de migração no projeto que não foi 
executado e que você não precisa mais (como um que gera um erro), basta excluí-lo 
do projeto ou modificar suas queries SQL para realizar as operações adequadas 
para o seu caso.

Agora você entendeu melhor a causa de certos erros que podem acontecer ao rodar 
ou mesmo reverter migrações, dependendo das queries que foram geradas 
automaticamente pelo TypeORM. 

---------------------------------------------------------------------------------

Lisa é desenvolvedora e está trabalhando em um projeto que possui um Data Source 
configurado para a CLI do TypeORM, indicando corretamente os caminhos das 
entidades e o caminho das migrações no projeto.

O projeto já tem uma migração que constrói a estrutura inicial do Banco de 
Dados, criando uma tabela chamada filmes com as colunas nome e ano_lancamento. 
Lisa precisava adicionar uma coluna genero na tabela filmes no banco de dados, 
para isso ela incluiu a propriedade genero no código da entidade. O problema é 
que essa mudança ainda precisa ser refletida no banco de dados.

Quais comandos da CLI do TypeORM Lisa deve executar para que isso aconteça?

    migration:generate caminho-da-migracao/adiciona-coluna-genero-em-filmes
    migration:run.

Depois de modificar o código da entidade, o comando migration:generate identifica 
essa mudança e gera uma migração correspondente. Em seguida, o migration:run executa 
as migrações geradas que ainda não foram executadas, ou seja, ele irá executar a 
migração adiciona-coluna-genero-em-filmes e vai adicionar a coluna no banco de dados.

---------------------------------------------------------------------------------

Embarcar em um projeto em andamento que usa um BD:
    Você revisou as etapas necessárias que novos membros de um time devem 
    realizar obrigatoriamente: instalar as dependências, criar as variáveis 
    de ambiente, configurar o Docker e criar um servidor com um BD no 
    Postgres Admin.

Instalar a CLI do TypeORM e configurar um Data Source para ela:
    A CLI é necessária para trabalharmos com migrações no TypeORM.

Versionar o BD com migrações:
    Assim como o Git realiza o versionamento de código, as migrações realizam 
    o versionamento de Banco de Dados. Nós geramos e executamos uma migração 
    para cada nova alteração no BD que é realizada. As migrações contêm queries 
    SQL que aplicam uma alteração com o método up ou desfazem essa alteração 
    com o método down. Assim, é possível alternar facilmente entre diferentes 
    versões do Banco de Dados e sempre alinhar o time com a versão mais recente.

Utilizar os comandos para gerar, executar, reverter e mostrar migrações:
    Os comandos são migration:generate, migration:run, migration:revert e 
    migration:show. Para facilitar o uso, criamos o script "typeorm": 
    "typeorm-ts-node-esm --dataSource src/db/data-source-cli.ts".

---------------------------------------------------------------------------------

Antes de começarmos é preciso que o ambiente já esteja configurado. Vamos relembrar alguns passos importantes?

    Realize a configuração do ambiente de acordo com o Preparando Ambiente da aula 1;
    Verifique se as migrações já foram rodadas e criaram as versões no banco de dados. Você pode visualizar as tabelas acessando o localhost do seu PostgresAdmin;
    Caso as tabelas não tenham sido criadas, rode as migrações com comando npm run typeorm migration:run.

Depois disso, precisamos realizar a instalação de uma ferramenta importante, a CLI do Nest.js.

A CLI do Nest.js é uma interface de linha de comando que ajuda a inicializar, desenvolver e manter suas aplicações Nest.js. Essa ferramenta é útil de diferentes formas, inclusive possui uma técnica para a criação de camadas de visão e controle do CRUD automaticamente a partir do padrão arquitetural MVC , facilitando assim a manutenção do sistema. Esse recurso se chama scaffolding. Dessa forma, a CLI facilita o desenvolvimento de softwares a partir das boas práticas.

Utilizamos o comando a seguir para instalar a CLI do Nest.js globalmente:

---------------------------------------------------------------------------------

https://whimsical.com/der-ecommerce-compree-primeiro-474CA2Gwv6Me5URhCeEPc5

https://whimsical.com/der-ecommerce-compree-JgTNdk8pXrEXh8xSZSwgay

No vídeo anterior, você conferiu os Diagramas de Entidade e Relacionamento 
(DER) referentes ao projeto. Você pode acessá-los nos seguintes links:

    DER Compree Inicial;
    DER Compree com pedidos.

Um diagrama de entidade relacionamento reproduz, de forma gráfica ou visual, 
como as entidades ou tabelas de uma aplicação estarão vinculadas a um banco 
de dados. Criar essa representação visual facilita a compreensão de como 
estabelecer os relacionamentos 1:1 (um para um),1:N (um para muitos) e N:M 
(muitos para muitos). Para praticar você pode, inclusive, desenhar em um papel 
as tabelas e seus conectores.

Para simplificarmos ainda mais os relacionamentos, podemos descrevê-los em 
tópicos, como no exemplo a seguir:

Relação entre Usuário e Pedido

    Um Usuário pode ter vários Pedidos
    Cada Pedido pertence a apenas um Usuário (ou seja, um mesmo pedido não pode 
    pertencer a vários usuários)
    Assim, temos um Usuário para muitos Pedidos (1:N)

Relacionamento entre Pedido e Produto

    Um Pedido pode ter vários Produtos
    Um Produto pode pertencer a vários Pedidos
    Assim, temos muitos Pedidos para muitos Produtos

O assunto sobre relacionamentos e banco de dados é extenso e requer atenção, 
sugerimos que você leia o Artigo MER e DER: Definições, Banco de Dados e 
Exemplos, e também estude a Formação de Modelagem de dados.

---------------------------------------------------------------------------------

Uma das principais vantagens do Nest.js é a sua CLI, que oferece uma ampla 
gama de comandos para ajudar na criação e gerenciamento de sua aplicação. 
Um recurso especialmente útil é o CRUD generator, que traduzindo significa 
gerador de CRUD. Com o gerador CRUD, você pode criar rapidamente todas essas 
perações para um recurso específico do seu domínio, como usuários, produtos, 
pedidos, etc.

Para usar o gerador CRUD, você precisa ter o Nest.js e sua CLI instalados e 
configurados em seu ambiente de desenvolvimento. Em seguida, abra o terminal 
ou prompt de comando e navegue até o diretório do seu projeto. Agora você 
está pronto para executar o comando da CLI para criar o CRUD.

O comando para gerar o CRUD é o seguinte:

nest generate resource <nome-do-recurso>

Substitua <nome-do-recurso> pelo nome do recurso que você deseja criar. 
Por exemplo, se você quiser criar um CRUD para usuários, o comando seria:

nest generate resource users

Ao executar esse comando, a CLI do Nest.js criará automaticamente os 
arquivos necessários para o recurso de usuários. Isso inclui um controlador 
(controller), um serviço (service) e uma entidade (entity), se você estiver 
usando um banco de dados.

O controller é responsável por lidar com as requisições HTTP relacionadas 
ao recurso. Ele contém os métodos para criar, ler, atualizar e deletar os 
objetos do recurso. O Service é responsável pela lógica de negócio 
relacionada ao recurso, enquanto a Entity representa a estrutura de dados 
do recurso, se estiver usando um banco de dados.

Caso a CLI do Nest.js não atualize automaticamente o arquivo app.module.ts 
para importar o controlador e o serviço do recurso que você criou, é 
necessário importá-lo manualmente. Isso garante que o Nest.js reconheça e 
gerencie corretamente o novo recurso em sua aplicação.

Depois de executar o comando, você pode personalizar o código gerado de 
acordo com as necessidades do seu aplicativo. Por exemplo, você pode 
adicionar validações, personalizar as rotas ou adicionar relacionamentos 
com outras entidades.

Em resumo, a CLI do Nest.js é uma ferramenta poderosa que simplifica o 
processo de desenvolvimento de aplicativos com Nest.js. O recurso do 
gerador CRUD permite criar rapidamente operações básicas para recursos 
de domínio, economizando tempo e esforço. Utilize a CLI para acelerar o 
desenvolvimento e focar em aspectos mais complexos e personalizados de 
seus projetos.

---------------------------------------------------------------------------------



A padronização e convenção de nomenclatura de variáveis, funções, arquivos, 
dentre outros é uma boa prática que permite a consistência do código em projetos 
que apresentam diferentes níveis de complexidade.

Entretanto, a padronização em TypeScript, Nest.js ou no Banco de Dados não é a 
mesma e essas convenções diferentes aparecem com frequência em nosso projeto. 
É por esse motivo que algumas nomenclaturas no código parecem “variar” de 
padronização. Porém, o que ocorre é a utilização do padrão referente a cada 
ferramenta.

Vamos entender um pouco mais sobre isso?

Padrões de nomenclatura com TypeORM, PostgreSQL e Nest.js juntos

Há algumas convenções de nomenclatura específicas que são recomendadas para 
manter uma estrutura consistente e facilitar o desenvolvimento, como:

    Nomes de entidades no JavaScript: em geral, recomenda-se utilizar o padrão 
    PascalCase para nomear as entidades. Por exemplo, uma entidade para 
    representar um usuário pode ser chamada de User.
    Nomes das tabelas no banco de dados: alguns padrões podem ser utilizados, 
    mas nesse projeto optamos pelo plural e snake_case para representar o 
    conjunto de dados. Por exemplo, tabelas chamadas como usuarios, pedidos, 
    produtos, itens_pedidos etc.
    Nomes de colunas no JavaScript: utilize camelCase para nomear as colunas da 
    tabela do banco de dados. Por exemplo, uma coluna para armazenar o nome 
    completo de um usuário pode ser chamada de fullName.
    Nomes de colunas no banco de dados: já para as colunas, a convenção é
     utilizar o singular e snake_case. Por exemplo: nome, descricao, valor, 
     quantidade_disponivel etc.
    Chaves primárias (primary key): recomenda-se utilizar o nome id para a 
    chave primária das entidades. O TypeORM identifica automaticamente a 
    coluna id como chave primária, mas também permite definir outros nomes 
    se necessário.
    Chaves estrangeiras (foreign key): para as chaves estrangeiras, é comum 
    adicionar o nome da entidade relacionada, seguido de Id. Por exemplo, se 
    uma entidade Pedido possui uma relação com a entidade Usuario, a coluna 
    de chave estrangeira pode ser chamada de usuarioId.
    Relações (relation): para estabelecer relações entre entidades no TypeORM, 
    é possível usar decorators como @ManyToOne, @OneToMany, entre outros. Ao 
    utilizar esses decorators, é recomendado utilizar o nome da entidade no 
    singular para definir a relação. Por exemplo, se uma entidade Usuario 
    possui vários pedidos, a relação pode ser definida como @OneToMany(() => 
    Pedidos, pedido => pedido.usuario).

Essas são apenas algumas das convenções mais comuns ao usar o TypeORM com o 
PostgreSQL e o Nest.js. No entanto, é importante ressaltar que essas 
convenções podem ser adaptadas de acordo com as necessidades específicas 
do projeto e das diretrizes da equipe, ou seja, as convenções podem variar 
dependendo do padrão adotado pela equipe ou organização, e é essencial manter
 a consistência dentro do projeto para facilitar a leitura e manutenção do código.

---------------------------------------------------------------------------------

Você recebeu uma tarefa para criar um novo domínio em uma aplicação de uma 
rede de petshops. Esse desafio consiste em construir entidade, controller, 
DTO e testes para os animais de estimação, que você chamará de pets, com o 
framework Nest.js.

Além disso, sua liderança sugeriu que você utilizasse o recurso de CRUD 
Generator do Nest para otimizar o desenvolvimento.

A respeito desse recurso, marque as alternativas corretas:

Ao criar um novo recurso com o CRUD Generator, o Nest automaticamente 
importa o módulo desse recurso no app.module.ts.

O CRUD Generator é uma ferramenta prática para geração automática de CRUD 
e acelera o desenvolvimento de aplicações. Além disso, os recursos com os 
comandos nest g resource nomedodomínio realizam scaffolding do domínio a 
partir do padrão de arquitetura selecionado.
Alternativa correta

O comando nest g resource pet irá realizar o scaffolding de um novo recurso 
chamado pet, criando seu controlador, serviço, módulo, entidade, DTOs e 
testes.

O scaffolding no Nest.js é uma prática que agiliza o desenvolvimento de 
aplicativos e garante uma estrutura coesa desde o início. Com os comandos 
na CLI você gera automaticamente módulos, controladores, provedores e outros 
artefatos da aplicação. Ao utilizar o scaffolding, você pode se concentrar 
mais na lógica de negócios e menos na configuração básica do projeto. 
O Nest.js também oferece a flexibilidade de personalizar os modelos gerados, 
permitindo adaptar a estrutura às necessidades específicas do projeto.

---------------------------------------------------------------------------------

Analisar o DER da API:
    Entendemos como os relacionamentos da nossa API seriam implementados 
    a partir de um Diagrama de Entidade e Relacionamento (DER).
Usar o Scaffolding com Nest.js:
    Utilizamos a CLI do Nest.js para criar domínio de pedidos com o CRUD 
    generator.
Criar relacionamentos 1:N com Nest.js e TypeORM:
    Criamos um relacionamento 1:N entre entidade Usuários e Pedidos no 
    Banco de dados com TypeORM.

---------------------------------------------------------------------------------

Uma dúvida pertinente que pode surgir é sobre a criação de uma tabela auxiliar. 
Afinal, não seria mais fácil estabelecer um relacionamento Muitos para Muitos 
diretamente do que precisar de uma tabela auxiliar?

Para respondermos essa questão precisamos entender o papel de uma tabela 
auxiliar. Vamos lá?

A tabela auxiliar desempenha algumas funções importantes. No caso do 
relacionamento N:M é atuar como uma entidade intermediária que faz a ponte 
entre as duas tabelas principais envolvidas no relacionamento, contendo 
informações sobre as associações entre os registros das tabelas principais.

Vamos conferir algumas funções das tabelas auxiliares:

    Representar o relacionamento entre tabelas N:M: por armazenar os registros 
    que definem as associações entre os elementos de tabelas principais, a 
    tabela auxiliar permite o estabelecimento da ligação entre muitos para 
    muitos.
    Permitir atributos adicionais: a tabela auxiliar é flexível no processo 
    de adição de atributos extras dentro de um relacionamento N:M. Em nossa 
    entidade itemPedido, podemos inserir o campo de precoVenda e quantidade, 
    por exemplo.
    Facilitar operações de join: através da tabela auxiliar é possível 
    facilitar a obtenção de dados relacionados, aprimorando a performance 
    das consultas que envolvem o relacionamento N:M.
    Deixar o banco de dados modular e escalável: ao abstrairmos o relacionamento
    N:M com a presença de uma tabela auxiliar, o banco de dados se torna mais 
    modular e escalável. Essa divisão possibilita a adição e remoção de 
    associações sem comprometimento direto das tabelas principais, ou seja, 
    seu sistema não fica engessado para implementações ou mudanças posteriores.

As conexões entre chaves estrangeiras das tabelas relacionadas à tabela 
auxiliar objetivam manter a integridade referencial do relacionamento N:M, 
evitando inconsistências na integridade dos dados.

Durante a modelagem do banco de dados, avalie a possibilidade de estabelecer 
uma tabela auxiliar e identifique a relevância de sua criação para o seu produto.

---------------------------------------------------------------------------------

O item do pedido, ou seja, o seu id, ainda não está relacionado ao pedido na 
tabela e também não é devolvido na resposta da requisição. O JSON traz somente 
os valores da propriedade quantidade. Como podemos relacioná-los?

O primeiro passo é implementar o DTO para manipulação dos dados.

Vamos renomear o arquivo create-pedido.dto.ts para CriaPedido.dto.ts, mas:

    Lembre de atualizar as importações do arquivo;
    Em seguida, implemente a classe de ItemPedidoDTO e CriaPedidoDTO.

1 - Acesse o diretório pedidos\dto, crie um arquivo CriaPedidoDto.ts e delete 
o arquivo create-pedido.dto.ts.

2 - Realize as importações da classe Type do 'class-transformer', que é a 
biblioteca usada para transformar objetos JavaScript em instâncias de classes 
personalizadas.

3 - Faça as importações de ArrayMinSize, IsArray, IsInt, ValidateNested do 
módulo class-validator'.

4 - Instancie uma classe chamada ItemPedidoDTO e informe que haverá um @IsInt 
(que irá validar se uma propriedade é realmente um inteiro), com a propriedade 
quantidade do tipo number.

5 - Em seguida você deverá criar uma classe chamada CriaPedidoDTO que 
comporta os decorators a seguir:

    @ValidateNested(): valida objetos aninhados.
    @ArrayMinSize: valida se um array tem o tamanho mínimo especificado.
    @IsArray: valida se uma propriedade é um array.
    @Type: valida o tipo de objeto declarado.

import { Type } from 'class-transformer';
import { ArrayMinSize, IsArray, IsInt, ValidateNested } from 'class-validator';

class ItemPedidoDTO {
  @IsInt()
  quantidade: number;
}

export class CriaPedidoDTO {
  @ValidateNested()
  @IsArray()
  @ArrayMinSize(1)
  @Type(() => ItemPedidoDTO)
  itensPedido: ItemPedidoDTO[];
}

O código acima define duas classes TypeScript: ItemPedidoDTO e CriaPedidoDTO, 
que são usadas para validar os dados de um pedido.

A classe ItemPedidoDTO define a estrutura de um item de pedido. Ela possui 
uma propriedade chamada quantidade, que deve ser um número inteiro de acordo 
com a validação @IsInt().

A classe CriaPedidoDTO define a estrutura de um pedido completo. Ela possui a 
propriedade itensPedido, que deve ser um array de objetos ItemPedidoDTO de 
acordo com as validações @ValidateNested(), @IsArray() e @ArrayMinSize(1). A 
validação @ValidateNested() é usada para validar os objetos aninhados na 
propriedade itensPedido.

A anotação @Type(() => ItemPedidoDTO) é usada em conjunto com a validação 
@ValidateNested() para especificar o tipo dos objetos aninhados na propriedade 
itensPedido como instâncias da classe ItemPedidoDTO.

Essas classes e validações podem ser usadas para garantir que os dados de um 
pedido estejam corretos e sigam as regras estabelecidas pelas validações.

Nosso projeto agora está preparado para trabalharmos com o cadastro completo 
de itens de um pedido. 

---------------------------------------------------------------------------------



Imagine que você construiu um banco de dados para gestão de consultas médicas. 
Você tem então uma entidade de consultas e outra tabela auxiliar com horários 
vagos. Quando um paciente agenda, atualiza ou precisa deletar uma consulta, 
data e horário disponíveis do médico também precisam sofrer atualização. 
Pensando nesse caso, é possível manipular esses dados com processos em cascata 
no seu banco de dados. Vamos entender melhor o que são esses processos?

Em primeiro lugar, cascata, em banco de dados é diferente do conceito de 
Modelo cascata ou waterfall de desenvolvimento. O processo em cascata é uma 
operação de deleção, criação ou atualização aplicada automaticamente aos 
registros relacionados através quando determinada operação é executada.

Os relacionamentos entre entidades são trabalhados com as Chaves 
estrangeiras e Primárias, tudo para manter sua integridade relacional. 
Por sua vez, os processos em cascate impedem a presença de dados “orfãos”, 
ou seja, dados que não estão associados a um pai ou filho em nosso banco 
de dados.

Além disso, também ao habilitar essa funcionalidade, não despendemos mais 
tempo escrevendo códigos adicionais para excluir os registros filhos de 
forma independente, poupando tempo e deixando nosso código menos verboso.

E como implementamos processos em cascata com TypeOrm e Nest.js?

Podemos notar que utilizamos o termo cascade para a atualização ou 
deleção de linhas ou até tabelas inteiras em cascata. No entanto, durante 
a implementação do código, nos deparamos com dois casos de uso, que 
você confere a seguir:

    O termo cascade: true, em letras minúsculas e aparecendo como uma 
    chave-valor dentro do relacionamento com TypeOrm;
    O termo CASCADE, em letras maiúsculas e surgindo como o valor de 
    uma propriedade, confira no exemplo a seguir:

onDelete: 'CASCADE', onUpdate: 'CASCADE',	

Mas será que ambos significam a mesma coisa?

O cascade:true é a forma que TypeORM faz referência ao processo de 
cascata, ou seja, é a opção específica que é configurada no relacionamento 
para habilitar o comportamento em cascata e automatizar as operações em 
registros filhos.

Por outro lado, CASCADE é um termo oriundo diretamente dos bancos relacionais 
e se refere às operações nos registros relacionados.

Os processos em cascata são úteis em diferentes contextos de nossas aplicações. 
Porém, é importante trabalharmos com cautela para que não ocorra a exclusão 
de dados importantes que estão relacionados, seu uso deve ser executado quando 
você possuir a certeza do comportamento esperado. Para isso, a modelagem do 
banco de dados surge como um recurso essencial para realização eficiente do 
cascade em seu projeto.

Leia também:

    Documentação do TypeORM;
    https://typeorm.io/relations#cascades
    Documentação do Postgres.
    https://www.postgresql.org/docs/current/ddl-constraints.html#:~:text=In%20this%20case%2C%20CASCADE%20means,its%20referencing%20columns%20are%20null.

---------------------------------------------------------------------------------

Antes de concretizarmos a operação de atualização de um pedido, precisamos 
implementar a propriedade que qualifica o status do pedido. Para tal, vamos 
seguir alguns passos:

    Para manipular a informação via DTO através da criação de uma classe 
    chamada AtualizaPedidoDto com o decorator @IsEnum recebendo a classe 
    StatusPedido como parâmetro.
    Preparar a rota no controller para a busca através de um id, e trabalhar 
    a atualização com um decorator @Patch.
    Implementar o serviço de atualização com um método chamado atualizaPedido, 
    que irá buscar o pedido via id, realizar a alteração e retornar o 
    pedidoRepository alterado.

---------------------------------------------------------------------------------



Em arquitetura de software há diversas formas de criar aplicações. Algumas se 
baseiam na separação de responsabilidades do seu código em camadas, que tornam 
o seu código mais organizado e pode seguir vários padrões de estruturação em 
camadas. No nosso projeto, estamos utilizando quatro camadas fundamentais: os 
controllers, os serviços, os repositórios e a camada de persistência. Entenda 
melhor cada uma delas:

    A camada de controller é responsável por receber as requisições HTTP e 
    direcioná-las aos serviços adequados. Essa camada define os endpoints da 
    API e os métodos HTTP associados a cada um deles. Com o Nest.js, é possível 
    definir rotas de forma declarativa através dos decorators para associar as 
    rotas a funções específicas dentro do controller. Essas funções são 
    responsáveis por receber os dados da requisição, chamar os serviços 
    correspondentes e retornar a resposta adequada para o cliente.

    Já a camada de serviço (service) é responsável por conter a lógica de 
    negócios de nossa API. Ela é a ponte entre a camada de controle e a camada 
    de repositórios. Os serviços podem conter regras de negócio específicas e 
    realizar validações antes de executar métodos dos repositórios.

    A camada de repositórios interage diretamente com o banco de dados. No 
    nosso projeto, ela não possui arquivos próprios, pois já está sendo abstraída 
    pelos repositórios do TypeORM. Um repositório é capaz de interagir diretamente 
    com o banco de dados e realizar operações como consultas, inserções, 
    atualizações e exclusões.

    A camada de persistência é o banco de dados em si. No nosso código, 
    ele é representado pelas entidades.

Quando combinamos essas camadas com o Nest.js, TypeORM e PostgreSQL, temos 
uma estrutura poderosa para o desenvolvimento de aplicativos back-end.

O Nest.js oferece uma arquitetura modular e baseada em injeção de dependências, 
facilitando a criação e o teste de cada uma dessas camadas separadamente. O 
TypeORM simplifica a interação com o banco de dados, fornecendo uma API fácil 
de usar para realizar operações de CRUD. E o PostgreSQL é um banco de dados 
confiável e escalável, adequado para aplicações de diferentes tamanhos e 
requisitos.

Em resumo, o uso de camadas de serviço, controller e persistência no Nest.js, 
em conjunto com TypeORM e o PostgreSQL, proporciona uma estrutura sólida e 
organizada para o desenvolvimento de aplicações back-end, pois essa abordagem 
ajuda a separar as responsabilidades, facilitando a manutenção, teste e 
o aprimoramento do código.

Continue estudando sobre arquitetura de software para você adquirir uma 
perspectiva de mais alto nível em relação a estruturação de suas aplicações.

Confira a formação de Engenharia de Software para conhecer mais sobre o tema.

---------------------------------------------------------------------------------

Sua equipe está desenvolvendo uma aplicação de comércio eletrônico e você ficou 
responsável por implementar um relacionamento N:M entre os modelos "Pedido" e 
"Produto" usando o Nest.js e o TypeORM. O objetivo é permitir que um pedido 
possa estar associado a vários produtos e, ao mesmo tempo, um produto possa 
estar presente em vários pedidos.

Nesse contexto, marque as afirmações corretas a respeito desse tipo de 
relacionamento:
Selecione 2 alternativas 

Em um relacionamento N:M, a tabela auxiliar carrega duas chaves 
estrangeiras: uma relacionada a cada tabela principal.

A tabela auxiliar, no contexto de intermediária para um relacionamento 
N:M, possui as chaves estrangeiras que referenciam as duas tabelas 
principais.Cada registro da tabela auxiliar relaciona um registro de 
uma tabela principal ao registro de outra tabela principal.

Tabelas auxiliares, em relacionamentos N:M, ajudam na manutenção da 
integridade relacional dos dados, contribuem para o processo de 
escalabilidade e apresentam maior controle na persistência dos dados.

As tabelas auxiliares possuem atributos próprios que se referem aos 
relacionamentos estipulados. Além de ser evidenciada como uma boa prática, 
a criação de tabelas auxiliares proporciona maior legibilidade do código e 
facilidade na manutenção do banco de dados. No entanto, é importante sempre 
verificar a modelagem do banco de dados e lógica de negócio para implementação 
dos relacionamentos.

---------------------------------------------------------------------------------

    Implementar relacionamentos N:M:
        Implementamos relacionamentos do tipo muito para muitos a partir da 
        construção de uma tabela auxiliar com os decorators do TypeORM.
    Aplicar processos em cascata no banco de dados:
        Estabelecemos processos em cascata para atualização de um pedido através 
        do TypeORM com o recurso cascade: update, permitindo assim a alteração 
        automática da tabela de produtos a partir da itensPedido.

    Implementar regras de negócio no serviço:
        Aprendemos como verificar se um determinado id de produtosIds está 
        incluso na lista de itensPedido para buscar um produto. Em seguida 
        conseguimos modificar o valor do produto relacionado a partir do 
        precoVenda, inserimos a quantidade com informações do DTO e adicionamos 
        a regra de negócio que subtrai um produto da tabela de produtos após a 
        criação de um pedido.

---------------------------------------------------------------------------------

Nesta aula, você aprendeu a criar um filtro de exceções do Nest e utilizá-lo de 
forma global. Em src/app.module.ts, adicionamos o seguinte código no decorator 
@Module:

  providers: [
    {
      provide: APP_FILTER,
      useClass: FiltroDeExcecaoGlobal,
    },
  ],

Onde o FiltroDeExcecaoGlobal é o filtro que criamos. Mas sabia que há outras 
formas de aplicar um filtro na aplicação? Vamos ver alguns exemplos?

    Esse assunto também pode ser estudado na seção Binding Filters da 
    documentação do Nest.

Registramos o nosso filtro de forma global na aplicação, mas é possível 
registrá-lo a nível de controlador ou mesmo a nível de um método. Para ambos 
os casos, utilizamos o decorator @UseFilters do módulo @nestjs/common do Nest.

    Nos próximos exemplos, o nome do filtro utilizado será FiltroDeExcecao.

Para usar o nosso filtro diretamente em um método de controlador, por exemplo, 
o criaPedido do controlador de pedidos, teríamos o seguinte:

  @Post()
  @UseFilters(FiltroDeExcecao)
  async criaPedido(/* parâmetros... */) {
    // código do método...
  }

Desse modo, o filtro seria aplicado apenas nesse método, mas não nos outros.

Como parâmetro do decorator @UseFilters, você também pode passar uma 
instância do filtro em vez da própria classe, e ficaria assim:

  @Post()
  @UseFilters(new FiltroDeExcecao())
  async criaPedido(/* parâmetros... */) {
    // código do método...
  }

Contudo, o próprio Nest afirma que isso pode aumentar o uso de memória da 
aplicação, então é mais recomendado passar a classe diretamente quando possível, 
já que o Nest consegue reutilizar sempre a mesma instância da classe através 
da aplicação.

A outra forma de utilizar o filtro é diretamente em um controlador. 
Utilizando em PedidoController, por exemplo, teríamos o código abaixo:

@Controller('pedidos')
@UseFilters(FiltroDeExcecao)
export class PedidoController {
  // código do controlador...
}

Desse modo, o filtro de exceções será aplicado em todas as rotas do controlador,
mas não para as rotas de outros controladores.

---------------------------------------------------------------------------------

Considere que você tem uma aplicação que ainda não possui nenhum filtro e 
o time está pedindo para você criar um que capture todos as exceções não 
tratadas. Além disso, quando a exceção não for do tipo HttpException, o 
retorno da API deve trazer informações adicionais, como o caminho e o horário 
em que o erro ocorreu.

Marque as alternativas corretas a respeito do filtro que deve ser criado:

O filtro pode utilizar diretamente o objeto de resposta do Express para criar 
o retorno da API.

Com o contexto da aplicação, podemos utilizar o método getResponse<Response>() 
para obter o objeto de resposta do Express. Importamos a interface Response do 
Express e utilizamos como generics para especificar melhor o tipo do retorno.

O filtro pode sobrescrever o tratamento de erros padrão do Nest.

Assim, será possível incluir informações adicionais no filtro.

---------------------------------------------------------------------------------

    Tratar recursos não encontrados:
        Conferimos alguns casos onde os métodos do TypeORM podem retornar null 
        para um registro não encontrado no BD. Para esse casos, lançamos um 
        erro com a classe NotFoundException.

    Tratar mais requisições incorretas:
        Tratamos os casos onde a pessoa tentava solicitar uma quantidade de um 
        produto maior que a cadastrada. Nesse caso, lançamos um erro com a 
        classe BadRequestException.

    Criar um filtro de exceções:
        Um filtro de exceções é uma classe que implementa a interface 
        ExceptionFilter e aplica o decorator @Catch(). Com um filtro, 
        podemos sobrescrever o tratamento de erros padrão do Nest.

    Capturar todos os erros da aplicação:
        Para capturar todos os erros não tratados, removemos o HttpException 
        do @Catch(). Assim, conseguimos obter também os erros de BD, por 
        exemplo, e incluir informações adicionais no objeto de erro retornado 
        pela API.

---------------------------------------------------------------------------------

No vídeo anterior, você conheceu o Mapped Type (Tipo Mapeado) PartialType(), 
que significa “Tipo Parcial”. Com os tipos mapeados, é possível reduzir 
bastante o código de uma classe e evitar repetições, principalmente ao 
trabalhar com DTOs.

O PartialType(), em específico, recebe uma classe como parâmetro e aplica em 
todas as suas propriedades o decorator @IsOptional() do class-validator. 
O código que usamos no AtualizaUsuarioDTO, por exemplo, ficou assim:

export class AtualizaUsuarioDTO extends PartialType(CriaUsuarioDTO) {}

Além desse tipo mapeado, existem mais três que são fornecidos pelo Nest: 
PickType(), OmitType() e IntersectionType(). Você pode entender mais 
sobre eles na seção Mapped types da documentação do Nest.

Mapped types: https://docs.nestjs.com/techniques/validation#mapped-types

---------------------------------------------------------------------------------

Antes de partirmos para o último vídeo, vamos tratar mais alguns recursos 
na aplicação para deixá-la mais refinada, caso você ainda não tenha feito! 
Nos casos abaixo, ainda não temos mensagens de erro apropriadas para quando 
o recurso não é encontrado:

    No arquivo usuario.service.ts, nos métodos buscaPorEmail, 
    atualizaUsuario e deletaUsuario.
    No arquivo produto.service.ts, método deletaProduto.
    No arquivo pedido.service.ts, método obtemPedidosDeUsuario 
    (quando o id do usuário não é encontrado).

---------------------------------------------------------------------------------

Segue o código final de cada método:
Arquivo usuario.service.ts

    Método buscaPorEmail:

  async buscaPorEmail(email: string) {
    const checkEmail = await this.usuarioRepository.findOne({
      where: { email },
    });

    if (checkEmail === null)
      throw new NotFoundException('O email não foi encontrado.');

    return checkEmail;
  }

Atenção: com o lançamento dessa exceção onde o email não é encontrado, 
existe outro arquivo da aplicação que devemos mudar. Se trata do 
src/usuario/validacao/email-eh-unico.validator.ts, que utiliza o 
método buscaPorEmail. Nesse arquivo, temos um validador que é utilizado 
na criação de um novo usuário, e ele verifica se o email do usuário 
já existe.

No entanto, como o método buscaPorEmail do serviço de usuário agora 
lança uma exceção caso o email não exista, precisamos tratar essa 
exceção no validador. Isso porque quando o email não existe, na verdade 
queremos que o validador permita a criação do usuário, então devemos 
retornar true no método validate. Se, por acaso, o erro lançado não for 
do tipo NotFoundException, então relançamos o erro para que ele seja 
tratado pelo filtro de exceções global. O código do método ficará assim:

// email-eh-unico.validator.ts

  async validate(value: any): Promise<boolean> {
    try {
      const usuarioComEmailExiste = await this.usuarioService.buscaPorEmail(
        value,
      );

      return !usuarioComEmailExiste;
    } catch (erro) {
      if (erro instanceof NotFoundException) {
        return true;
      }

      throw erro;
    }
  }

    Método atualizaUsuario:

Neste método, está sendo utilizado o update() do TypeORM, que atualiza 
o registro do BD. Contudo, esse método não retorna o usuário em si.

Para que a API retorne o usuário atualizado na resposta, você deve 
substituir o update() pelo método findOneBy() em conjunto com o 
save(), pois o save() retorna o usuário do BD:

  async atualizaUsuario(id: string, novosDados: AtualizaUsuarioDTO) {
   const usuario = await this.usuarioRepository.findOneBy({ id });

    Object.assign(usuario, novosDados);

    return this.usuarioRepository.save(usuario);
  }

    Método deletaUsuario:

  async deletaUsuario(id: string) {
    const resultado = await this.usuarioRepository.delete(id);

    if (!resultado.affected)
      throw new NotFoundException('O usuário não foi encontrado.');
  }

Nesse código, a propriedade resultado.affected diz quantos registros 
foram deletados do BD. Se o número deletado for 0, o código dentro 
do if será executado e o erro será lançado.
Arquivo produto.service.ts

    Método deletaProduto:

  async deletaProduto(id: string) {
    const resultado = await this.produtoRepository.delete(id);

    if (!resultado.affected) {
      throw new NotFoundException('O produto não foi encontrado');
    }
  }

Arquivo pedido.service.ts

    Método obtemPedidosDeUsuario:

Nesse método, podemos apenas chamar a função buscaUsuario que já está 
criada nesse arquivo e que também já está tratando o caso de usuário 
não encontrado. Portanto, o código ficará assim:

  async obtemPedidosDeUsuario(usuarioId: string) {
    const usuario = await this.buscaUsuario(usuarioId);

    return this.pedidoRepository.find({
      where: {
        usuario: { id: usuarioId },
      },
      relations: {
        usuario: true,
      },
    });
  }

Note que, além da busca que já estava sendo realizada com 
pedidoRepository.find(), adicionamos mais uma busca ao BD com o 
método buscaUsuario(). Assim, quando for passado um ID de usuário 
válido, serão realizadas duas buscas ao BD em vez de apenas uma.

Ou seja, teremos mais um custo de operação nesse caso, mas, em troca, 
conseguimos refinar o retorno da API, que agora consegue informar 
corretamente quando for passado um ID de usuário inválido.

Sem essa verificação, a API retornaria uma lista vazia sempre que 
fosse passado um ID inválido de usuário. Isso seria uma informação 
incorreta, pois daria entender que o usuário existe e que ele não 
possui pedidos. Ao invés disso, o melhor a ser feito é dizer que o 
usuário não foi encontrado, como no código acima.

Com isso, finalizamos o tratamento de mais alguns recursos da API!

---------------------------------------------------------------------------------

Você aprendeu como utilizar os Tipos Mapeados do Nest e como eles podem ajudar 
a evitar repetição de código ao trabalhar com classes, principalmente em DTOs.

Nesse contexto, considere o seguinte exemplo:

import { IsNotEmpty, Length } from 'class-validator';

export class CriaLivroDTO {
  @IsNotEmpty()
  nome: string;

  @Length(10, 5000)
  numeroPaginas: number;
}

Agora é necessário criar um DTO de atualização do livro, que permita atualizar 
qualquer uma de suas propriedades, opcionalmente. Além disso, devemos aplicar 
a mesma validação de dados que acontece no DTO de criação.

Quais das alternativas abaixo alcança esse objetivo de forma escalável?
Selecione 2 alternativas 

export class AtualizaLivroDTO extends PartialType(CriaLivroDTO) {}

No nosso caso, onde queremos manter todas as propriedades e validações de 
CriaLivroDTO e apenas tornar as propriedades opcionais, podemos usar o PartialType 
do Nest. Se um dia for necessário alterar a lógica de validação de uma 
propriedade, somente um dos arquivos precisa ser alterado.

export class AtualizaLivroDTO extends CriaLivroDTO {
  @IsOptional()
  nome: string;

  @IsOptional()
  numeroPaginas: number;
}

A classe está herdando de CriaLivroDTO e apenas adiciona o decorator 
@IsOptional() nas propriedades. Se um dia for necessário alterar a lógica 
de validação de uma propriedade, somente um dos arquivos precisa ser alterado.

---------------------------------------------------------------------------------

    Flexibilizar o filtro de exceções:
        Modificamos o seu código para não ficar totalmente atrelado ao Express. 
        Agora, caso o time queira alternar entre Express e Fastify, o filtro 
        já está preparado para essa mudança.

    Aplicar os Mapped Types do Nest:
        Utilizamos o PartialType para evitar repetição de código nos DTOs.

    Refatorar o código com Object.assign():
        Deixamos o código dos serviços mais limpo ao atribuir as propriedades 
        de um DTO a uma entidade. Além disso, para manter a atribuições seguras, 
        utilizamos o recurso de type assertion (asserção de tipo) do TypeScript.

---------------------------------------------------------------------------------