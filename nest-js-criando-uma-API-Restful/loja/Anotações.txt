Banco: docker-compose up -d
Projeto: npm run start

Criar um projeto com Nest é bem fácil, o próprio framework disponibiliza uma 
ferramenta de linha de comando (CLI) para que não tenhamos muito trabalho 
instalando e configurando vários pacotes diferentes usando o NPM.

Para criar um novo projeto Nest, tudo que precisamos fazer é usar o comando 
abaixo no terminal, em um diretório de sua preferência, informando o nome 
do projeto logo após o new. No nosso caso, o projeto se chamará loja.

npx @nestjs/cli new loja

Este comando pode demorar um pouco dependendo da sua conexão de internet, 
isso por que ele vai criar uma nova pasta com o mesmo nome do projeto, 
criar também o package.json que o Node precisa para gerenciar as 
dependências do projeto e baixar todas as dependências necessárias 
para a execução do Nest.

Após este processo finalizar, podemos entrar na pasta do projeto e usar 
o comando npm start para iniciar o projeto. Porém, como estamos em 
desenvolvimento, é mais interessante que usemos o servidor de desenvolvimento, 
já que este observa as mudanças que faremos nos arquivos e automaticamente 
reinicia o servidor para que possamos testar nossas mudanças no navegador 
ou no postman.

Para iniciar o servidor de desenvolvimento, basta usar o comando 
npm run start:dev. Lembre-se de parar o servidor anterior caso tenha iniciado. 
Você pode fazer isso com o atalho de teclado CTRL + C no terminal.

O Servidor estará ouvindo requisições na porta 3000, então podemos acessar 
http://localhost:3000 e veremos uma mensagem de Hello World. Experimente 
brincar um pouco com o Nest modificando esta mensagem que está no 
App.service.ts.

---------------------------------------------------------------------------------

Compreender o que é o Nest, e assim saber algumas de suas características.
A usar a CLI do Nest, para criar projetos.
Usar o npm para iniciar o servidor de do Nest para receber requisições.

---------------------------------------------------------------------------------

O Time do Alex está usando Nest em seu projeto para salvar os produtos de uma 
compra. O código do controller que recebe os dados é semelhante ao que se 
encontra abaixo. Porém, os dados não estão sendo salvos corretamente. 
Analise abaixo:

@Controller('/compras')
export class CompraController {
    construtor(private compraRepository: CompraRepository){}

    @Post()
    async registra(produtos: Produto[]) {
         this.compraRepository.salva(produtos);
    }
}

Assinale a alternativa que justifica o motivo dos dados não estarem sendo salvos 
corretamente:

R: O parâmetro produtos no método registra, não tem nenhum decorator indicando 
de onde o Nest deve buscar o valor, o correto seria decorar esse parâmetro 
com @Body.
Sem o decorator @Body, o Nest não sabe de onde buscar o valor desejado para o 
parâmetro do método. Neste caso, estamos pedindo para o Nest popular o parâmetro 
produtos com o que vier no body da requisição.

---------------------------------------------------------------------------------

O Nest possui outros decorators para capturar dados a partir de uma requisição, 
inclusive o @Body tem outros usos. Se precisarmos, por exemplo, capturar só uma 
parte de um objeto que foi enviado no body podemos passar o nome da chave desta 
parte do objeto e o Nest captura apenas este valor. Vejamos o objeto abaixo:

{
    numeroPedido: 23123
    produtos: [
        {
          nome: "camiseta nerd 2077",
          preco: 24.90
        }
    ]
}

Se quiséssemos capturar apenas a lista de produtos, poderíamos fazer 
@Body('produtos') e o Nest nos daria apenas os produtos ignorando o restante dos 
valores no objeto. Temos outros dois decoratos que se comportam de forma parecida 
com o @Body. Eles são o @Query e o @Param, o primeiro lida com query parameters 
e o segundo com parâmetros dinâmicos na URL. Veremos mais sobre estes outros 
durante nossos estudos.

---------------------------------------------------------------------------------

O Nest, em toda a sua documentação, estrutura seus exemplos sempre pensando em 
módulos. É uma ideia muito inspirada na arquitetura do Angular, inclusive, a 
estrutura e configurações são quase idênticas, com alguns ajustes.

A documentação às vezes deixa a entender que é uma boa ideia seguir pelo caminho 
de feature modules, onde cada feature do seu projeto deve ser isolada em um 
módulo; porém, pode ser uma estrutura de granularidade muito pequena - e isso 
pode variar de projeto para projeto.

No geral, acredito que cada módulo deve ser pensado de forma isolada, com poucas 
dependências, a fim de que se um dia precisarmos separar módulos dessa aplicação 
em aplicações diferentes, seguindo o caminho dos microserviços, possamos ter a 
facilidade de fazer isso com pouco esforço. Então, daí, temos a ideia de 
monólitos modulares, onde teremos uma aplicação monolítica, porém estruturada 
em partes com bom encapsulamento e baixo acoplamento.

Estruturar aplicações é uma arte da engenharia que sempre está em evolução. 
Então, não se apegue muito a estruturas, pois no geral as recomendações de cada 
framework são boas. Assim, segui-las no início é muito útil para aprender como 
cada coisa funciona, mas cada projeto tem suas necessidades. Decida com seu 
time o melhor caminho!

---------------------------------------------------------------------------------

A Injeção de dependências é um mecanismo que faz muito uso dos conceitos do 
SOLID, principalmente do princípio D, de Dependency Inversion, em que uma classe 
deveria depender de uma interface comum, sendo que qualquer objeto que implemente
essa interface é um objeto aceitável para uso na classe onde ele foi inserido.

Nosso controller, por exemplo, recebe um objeto específico de repositório, 
e isso nos dá pouca flexibilidade. Porém, se usássemos uma interface como 
dependência para nosso controller, poderíamos em tempo de desenvolvimento 
usar um repositório que armazena os dados na memória, como já fizemos. Mas, 
em teste ou em produção, poderíamos usar um outro repositório que salva de 
fato os dados em um banco de dados como o MySQL.

Vale lembrar que para que o Nest consiga injetar uma dependência de uma classe, 
a classe que será injetada deve estar presente no módulo como um provider e 
decorada com o @Injectable.

SOLID é um assunto que sempre dá para se estender nas discussões, há livros 
e mais livros que explicam e exemplificam cada um dos conceitos. Ficou curioso? 
O Livro do Alexandre Aquiles da Casa do Código pode esclarecer muito sobre o 
assunto. O Livro do Maurício Aniche também. Confira as referências deles a seguir:

Orientação a Objetos e SOLID para Ninjas: Projetando classes flexíveis
Desbravando SOLID: Práticas avançadas para códigos de qualidade em Java moderno
PS: Ambos os livros usam Java em seus exemplos, mas ainda é uma boa leitura.

---------------------------------------------------------------------------------

Antes de começar a fazer todo o cadastro de usuário, certifique-se que apagou os 
arquivos que não vamos precisar para o nosso projeto. São estes: app.service.ts, 
o app.e2e-spec.ts e app.controller.ts que estão dentro de src. Também apague as 
referências para estes arquivos dentro do app.module.ts. O app.module.ts deve 
ficar como o código abaixo:

import { Module } from '@nestjs/common';

@Module({
  imports: [],
})
export class AppModule {}COPIAR CÓDIGO
Depois disso, estamos prontos para iniciar! Sabemos que para tornar possível 
cadastrar um usuário, precisamos de uma rota que possa receber os dados do 
usuário via POST. Para isso, precisamos de um controller.

Vamos criar uma nova pasta dentro de src para agruparmos códigos que lidam 
com o usuário, o nome dessa pasta será usuario e dentro dela, criaremos dois 
arquivos, estes são: usuario.controller.ts e usuario.module.ts. O controller 
terá um código semelhante a este:

import { Body, Controller, Post } from "@nestjs/common";

@Controller('/usuarios')
export class UsuarioController {

    @Post()
    async criaUsuario(@Body() dadosDoUsuario) {
                return dadosDoUsuario;
    }

}COPIAR CÓDIGO
O módulo de usuário por outro lado, será apenas uma classe com o decorator 
@Module() adicionando nosso controller na configuração de controllers do
 módulo.

import { Module } from "@nestjs/common";
import { UsuarioController } from "./usuario.controller";

@Module({
    controllers: [UsuarioController],
})
export class UsuarioModule {}COPIAR CÓDIGO
Com isso, estamos quase prontos para receber dados via POST no endereço 
localhost:3000/usuarios. O último ponto é adicionar nosso módulo de usuário 
na árvore de módulos da aplicação Nest, como ilustra o código abaixo do 
arquivo app.module.ts:

import { Module } from '@nestjs/common';
import { UsuarioModule } from './usuario/usuario.module';

@Module({
  imports: [UsuarioModule],
})
export class AppModule {}COPIAR CÓDIGO
Ainda precisamos, de alguma forma, salvar os dados do usuário em nosso 
banco em memória. Para isso, criaremos nosso repositório de usuários, o nome 
do arquivo será usuario.repository.ts e ficará dentro da mesma pasta do 
controller de usuário:

import { Injectable } from "@nestjs/common";

@Injectable()
export class UsuarioRepository {
    private usuarios = [];

    async salvar(usuario) {
        this.usuarios.push(usuario);
    }
}COPIAR CÓDIGO
Também precisamos adicionar o nosso repositório dentro do módulo de usuário, 
para que o Nest consiga injetar objetos dessa classe em nosso controller:

import { Module } from "@nestjs/common";
import { UsuarioController } from "./usuario.controller";
import { UsuarioRepository } from "./usuario.repository";

@Module({
    controllers: [UsuarioController],
    providers: [UsuarioRepository]
})
export class UsuarioModule {}COPIAR CÓDIGO
Agora, em nosso controller, podemos receber o repositório através do 
construtor e usar o método salvar ao receber os dados do usuário.

@Post()
async criaUsuario(@Body() dadosDoUsuario) {
    this.usuarioRepository.salvar(dadosDoUsuario);
    return dadosDoUsuario;
}COPIAR CÓDIGO
Ótimo, já podemos cadastrar usuários, agora precisamos listá-los. 
Como fazer isso?

As mudanças que precisamos fazer são mínimas. Primeiro, precisamos 
devolver a lista de usuários que foram salvos no nosso usuario.repository.ts 
com um método novo que chamaremos de listar:

async listar() {
    return this.usuarios;
}COPIAR CÓDIGO
E em nosso usuario.controller.ts faremos um novo método que responde por GET 
e usa o método listar para devolver a lista de usuários que é retornada pelo 
repositório.

@Get()
    async listUsuarios() {
    return this.usuarioRepository.listar();
}COPIAR CÓDIGO
Agora podemos tanto cadastrar, quanto listar usuários!

---------------------------------------------------------------------------------

Para o cadastro de produtos, teremos a mesma estrutura de arquivos e a lógica 
será praticamente idêntica. Faremos da forma mais simples possível e vamos 
ajustando conforme for necessário. Dito isso, replique a estrutura que usamos 
para cadastrar usuários fazendo as devidas alterações para funcionar para produtos.

Criaremos uma nova pasta chamada produto dentro de src e nela criaremos os 
arquivos produto.controller.ts, produto.repository.ts e produto.module.ts.

Teremos a rota que responde via GET e via POST. Quando recebermos um GET, 
listaremos os produtos cadastrados, quando recebermos um POST, iremos capturar 
os dados que vierem no corpo de requisição e salvar estes dados no repositório de 
produtos.

O JSON abaixo é um exemplo que apresenta todos os dados necessários para 
cadastrar um produto:

{
    "nome": "Figura de ação Marvel Homem Aranha Olympus Homem Aranha E6358 de Hasbro Classic",
    "valor": 70.0,
    "quantidadeDisponivel": 10,
    "descricao": "Produto novo, bem acabado, alegria para colecionadores",
    "caracteristicas": [{
        "nome": "Fabricante",
        "descricao": "Iron Studios"
    },{
        "nome": "material",
        "descricao": "Plástico"
    }],
    "imagens": [{
        "url": "https://i.imgur.com/dwDZICq.jpg",
        "descricao": "Imagem do Homem Aranha"
    }],
    "categoria": "Colecionáveis",
    "dataCriacao": "2022-10-12T14:22:53.496Z",
    "dataAtualizacao": "2022-10-12T14:22:53.496Z"
}

Note que temos o nome do produto, valor, quantidade disponível, descrição, 
características, imagens, categoria e datas de criação e atualização 
do produto.

Não se preocupe ainda com a validação destas informações ou mesmo com a 
associação de quem foi o usuário que cadastrou um produto específico. 
Teremos uma atividade específica para isso.

---------------------------------------------------------------------------------

Criar rotas que respondem aos métodos GET e POST do HTTP usando os decorators 
@Get, @Post em conjunto com o @Controller.
Capturar dados que são enviados no corpo da requisição POST com o decorator @Body.
Criar módulos no Nest.
Usar a injeção de dependências com o @Injectable e configurando corretamente 
as classes no módulo.

---------------------------------------------------------------------------------

A Juliana, que está entrando no time e projeto em que você está desenvolvendo 
com NestJS, precisa escrever uma validação que verifica se um valor número foi 
enviado para API e ela está com dúvidas de como fazer isso. Qual das alternativas 
abaixo descreve a melhor forma da Juliana fazer essa validação?

R: Criar um DTO que descreve os dados que serão recebidos pelo endpoint e 
habilitar o pipe de validação globalmente na aplicação.
O DTO faria o papel de descrever os atributos que serão recebidos pelo Controller 
e habilitar o Pipe de validação global, faz a validação acontecer automaticamente.

---------------------------------------------------------------------------------

Criar DTOs é muito comum em vários tipos de projetos independente da linguagem 
ou do framework. Muitas vezes esses objetos podem aparecer com outros sufixos 
como Request, Form.

No geral, é apenas um objeto que define a interface entre duas camadas, 
normalmente, nas bordas mais externas das aplicações, ou seja, para indicar 
os campos e tipos permitidos nas entradas da aplicação; e claro, também é 
recomendado para definir as saídas.

A sigla é um acrônimo para Data Transfer Object, que quer dizer basicamente 
um objeto de transferência de dados. Por isso, ele é um objeto que também 
pode ser usado como base para validar os dados a serem recebidos por nossa 
aplicação.

Criar DTOs pode parecer trabalhoso ou mesmo chato, mas ele desempenha um
 papel importante no conjunto de boas práticas de desenvolvimento de 
 software.

 ---------------------------------------------------------------------------------

 Para validar produtos, precisamos quebrar o problema dessa validação em partes. 
 Primeiro, vamos relembrar como é o JSON que precisamos enviar para cadastrar um produto:

{
    "nome": "Figura de ação Marvel Homem Aranha Olympus Homem Aranha E6358 de 
    Hasbro Classic",
    "valor": 70.0,
    "quantidadeDisponivel": 10,
    "descricao": "Produto novo, bem acabado, alegria para colecionadores",
    "caracteristicas": [{
        "nome": "Fabricante",
        "descricao": "Iron Studios"
    },{
        "nome": "material",
        "descricao": "Plástico"
    }],
    "imagens": [{
        "url": "https://i.imgur.com/dwDZICq.jpg",
        "descricao": "Imagem do Homem Aranha"
    }],
    "categoria": "Colecionáveis",
    "dataCriacao": "2022-10-12T14:22:53.496Z",
    "dataAtualizacao": "2022-10-12T14:22:53.496Z"
}COPIAR CÓDIGO
Claramente, podemos quebrar esse JSON em algumas partes. Podemos observar que 
qualquer chave do JSON que tem uma lista como valor pode ser representada como uma 
classe diferente. Um exemplo seria as características de um produto que possuem, por 
enquanto, o nome do fabricante e o material do qual é feito o produto. 
Poderíamos separar isso em uma classe:

export class CaracteristicaProdutoDTO {
  nome: string;
  descricao: string;
}COPIAR CÓDIGO
A mesma ideia é válida para a validação das Imagens do produto. Isso nos geraria 
uma classe CriaProdutoDTO parecida com a que se encontra abaixo:

export class CriaProdutoDTO {
  nome: string;
  valor: number;
  quantidade: number;
  descricao: string;
  caracteristicas: CaracteristicaProdutoDTO[];
  imagens: ImagemProdutoDTO[];
  categoria: string;
}COPIAR CÓDIGO
A pergunta que fica é: como fazer o pipe validar um atributo que na verdade é 
uma lista de objetos de outra classe que também possui suas próprias validações? 
O class-validator nos ajuda nisso também.

Primeiro, precisamos validar que deve ser uma lista, ou melhor, um array. Para 
isso temos o decorator @IsArray(). Segundo, precisamos dizer para o class-validator
 que ele deve validar o objeto que está sendo referenciado pelo atributo, ou seja, 
 precisa fazer a validação aninhada ao atributo validado, para isso usaremos o 
 decorator @ValidateNested().

E, por último, precisamos informar o tipo do objeto ao qual o atributo faz 
referência, para transformar o objeto do atributo no tipo correto e para isso 
usaremos o decorator @Type() que por parâmetro espera uma função que retorne o 
tipo ao que o atributo está se referindo.

Juntando tudo, teremos uma validação que segue o seguinte formato para as 
características do produto:

@ValidateNested()
@IsArray() 
@Type(() => CaracteristicaProdutoDTO)
caracteristicas: CaracteristicaProdutoDTO[];COPIAR CÓDIGO
Com isso em mente, crie a validação de criação de produtos. Elas precisam 
atender aos critérios abaixo:

O nome do produto não pode ser vazio;
O valor do produto precisa ser um número positivo (não pode ser zero) e ter 
até duas casas decimais;
A quantidade precisa ser um número igual ou maior que zero;
A descrição não pode ser vazia ou maior que 1000 caracteres;
A lista de características do produto precisa ter pelo menos 3 itens;
A lista de imagens do produto precisa ter pelo menos 1 item;
A categoria do produto não pode ser vazia.
Algumas dessas validações não exploramos aqui, mas estão todas descritas na 
documentação do class-validator que você pode acessar neste link.

---------------------------------------------------------------------------------

O que são Pipes e seus casos de uso;
Como habilitar o pipe de validação global do Nest;
Como validar dados de requests com DTOs usando decorators do 
class-validator e class-transformer;
Validações mais complexas com objetos aninhados e arrays.


---------------------------------------------------------------------------------

O Ronaldo estava discutindo com seus colegas de trabalho sobre validações 
síncronas e assíncronas e ao ser indagado sobre quais os limites das validações 
síncronas, o mesmo respondeu de uma forma que gerou mais dúvidas do que sanou. 
Das alternativas abaixo, qual delas descreve bem os limites da validação síncrona:

R: É uma boa prática sempre usar uma validação assíncrona quando não conseguimos 
validar determinado dado de forma isolada. Se precisarmos consultar um terceiro, 
por exemplo, devemos fazer isso de forma assíncrona para não gerar uma trava nos 
processos onde as validações são enfileiradas por estarem segurando requisições HTTP.
As requisições HTTP ainda serão enfileiradas, afinal as respostas precisam ser 
devolvidas para o cliente, porém, o Node sabe lidar com isso e gerência os recursos 
para conseguir responder bem mesmo em grandes volumes de requisição, mas é nosso 
papel saber usar estes recursos.

---------------------------------------------------------------------------------

Estudamos vários decorators do Nest até o momento, mas você sabia que um decorator 
é apenas uma função como qualquer outra? Claro, dependendo do tipo de decorator 
que estamos criando, ele pode ser mais ou menos complexo de entender e escrever.

Isso porque temos decorators que podem ser usados a nível de classe como o 
@Controller do Nest. Vimos também os de nível de método como o @Get e outros 
decorators de HTTP que o Nest nos provê e temos também o decorator de propriedade 
que são todos que usamos em nossos validadores.

Quer saber como criar seus próprios decorators do zero? Aqui na Alura temos um 
curso de Typescript que ensina isso e muito mais, é um curso mais avançado, 
então verifique se tem os pré-requisitos certinhos:

---------------------------------------------------------------------------------

Validar que um e-mail já foi usado por outro usuário da nossa lógica precisa 
ser feito de forma assíncrona, visto que precisamos ir até o banco de dados 
ou mesmo outro serviço e esperar uma resposta.

Dito isso, crie um novo provider, que decorado com 
@ValidatorConstraint({ async: true }), implemente a interface 
ValidatorConstraintInterface. Este provider também deve receber como dependência 
no construtor o repositório de usuários, afinal, é o repositório que faz interação 
com o banco de dados.

A interface ValidatorConstraintInterface no seu método validate, espera que 
retornemos um valor booleano que indique se a validação foi um sucesso ou não. 
Se retornarmos o valor false, o erro de validação deve ser apresentado.

Para criar o decorator que executa a validação personalizada que acabamos de 
descrever, precisamos criar uma função. O nome desta função será o nome do decorator. 
E, como parâmetro, essa função deve receber um objeto do tipo ValidationOptions, 
interface importada do pacote class-validator.

Nossa função decorator deve retornar como resultado uma nova função que tem 
como parâmetros o objeto a ser validado e o nome da propriedade que será validada.

Esta segunda função deve executar o registro deste decorator no class-validator 

por meio do uso da função registerDecorator que recebe como argumento um objeto, 
informando o target alvo da validação, a propriedade a ser validada, as opções de 
validação, as constraints e por último o validator (classe que já escrevemos antes).

Validações assíncronas normalmente são mais complexas, envolvem mais partes da aplicação. 
Caso precise de uma implementação de referência, você pode consultar este commit.

---------------------------------------------------------------------------------

Criar uma validação assíncrona para aplicar validações complexas;
Criar um decorator para aplicar validações customizadas;
Usar o gestor de dependência do Nest para injetar objetos nas validações customizadas.

---------------------------------------------------------------------------------

Para atualizar um recurso em uma API Restful, temos dois métodos HTTP disponíveis, 
eles são o PUT e o PATCH. Qual usar?

De acordo com a especificação, o método PATCH deve ser utilizado para atualizar 
um recurso de forma parcial, ou seja, sem precisar informar todos os dados. 
Vejamos o exemplo abaixo de um recurso que representa um curso na Alura:

{
    "nome": "JavaScript Avançado",
    "nivel": "Avançado",
    "cargaHorariaEmHoras": 8
}COPIAR CÓDIGO
Para atualizar o nome apenas, usando o método PATCH, deveríamos 
enviar apenas o dado a ser atualizado, neste caso:

{
    "nome": "JavaScript Avançado: Programando de forma funcional"
}COPIAR CÓDIGO
Por outro lado, para atualizar o mesmo objeto usando o método PUT, 
deveríamos enviar o objeto completo, inclusive com os dados que não 
vamos atualizar. Dessa forma, para atualizar o nome do curso, o corpo 
da requisição seria o exemplificado abaixo:

{
"nome": "JavaScript Avançado: Programando de forma funcional",
    "nivel": "Avançado",
    "cargaHorariaEmHoras": 8
}COPIAR CÓDIGO
Para estarmos 100% alinhados com a especificação, deveríamos implementar 
as duas formas, muitas APIs implementam, outras não. Outras permitem você 
atualizar um recurso de forma parcial usando o PUT. Essa variação não é 
um problema, pois os times que implementaram essas APIs devem ter decidido 
isso seguindo algum critério.

---------------------------------------------------------------------------------

Para finalizar nosso CRUD, precisamos permitir a atualização dos dados de um 
usuário e também a remoção desse usuário da nossa aplicação. Antes disso, vamos 
fazer dois pequenos incrementos na nossa aplicação.

O primeiro desses incrementos é criar uma representação real do que é um usuário 
na nossa aplicação, a entidade usuário. Essa classe possui como atributos o nome, 
email, senha e id do usuário. Por fim, devemos usar essa entidade nos lugares onde 
lidamos com o usuário, ou seja, no repositório. A inicialização do nosso array de 
usuários deve ficar como se encontra abaixo:

private usuarios: UsuarioEntity[] = [];COPIAR CÓDIGO
Há mais lugares onde podemos usar nossa entidade de usuário como no controller, 
ao criar um usuário novo a partir do DTO de criação de usuário.

O segundo incremento é criar um novo DTO responsável por representar um usuário 
em nossa listagem; este deve apenas exibir o id e o nome do usuário. E atenção: 
já devemos refatorar nossa listagem de usuários para usar este novo DTO.

Para atualizar um usuário, precisamos criar um novo DTO, muito parecido com o 
de criação de usuário, porém, com todos os campos opcionais. Afinal, não sabemos 
quais campos o usuário irá atualizar. Contudo, caso o campo seja enviado, ele 
precisa passar pelas mesmas validações de criação de um usuário novo, ou seja, 
o e-mail não pode ter sido usado por outro usuário, etc.

Para validar um campo de forma opcional, podemos usar o decorator @IsOptional 
do class-validator como no exemplo abaixo:

@MinLength(6, { message: 'A senha precisa ter pelo menos 6 caracteres' })
@IsOptional()
senha: string;COPIAR CÓDIGO
Além disso, precisamos ter o cuidado de não permitir que o usuário atualize o 
próprio id no repositório, visto que vamos receber como parâmetro um objeto 
parcial de um usuário no método atualiza:

async atualiza(id: string, dadosDeAtualizacao: Partial<UsuarioEntity>) {}
Para remover um usuário, o processo é um pouco mais simples: precisamos 
apenas do ID do usuário enviado como parâmetro na URL usando o método DELETE.

 @Delete('/:id')
 async removeUsuario(@Param('id') id: string) {}COPIAR CÓDIGO
Um ponto de atenção importante é que tanto na atualização dos dados do usuário, 
 na remoção, precisamos retornar como resposta um objeto com uma mensagem 
 indicando se o usuário foi removido ou atualizado, assim como os dados desse 
 usuário, algo semelhante ao que se encontra abaixo:

return {
   usuario: usuarioRemovido,
  messagem: 'usuário removido com suceso',
};

---------------------------------------------------------------------------------

Chegou o momento de replicar tudo que fizemos para finalizar o CRUD de usuários, 
para produtos. Segue uma lista simples com tudo que precisamos fazer:

Criar a entidade de produto, essa será idêntica ao CriaProdutoDTO que já 
escrevemos antes; porém, com um atributo extra, o ID do produto que será um UUID;
Usar a entidade de produto nos métodos do repositório de produtos;
Ajustar o código do controller de produtos para que o mesmo crie um objeto da entidade 
produto ao tentar salvar um produto no repositório;
Criar o DTO de atualização de produto; este é idêntico ao de criação de produto, porém, 
com todos os campos opcionais com exceção do id do produto e o id do usuário;
Escrever o método atualiza no repositório de produto, no qual, dado um id e os dados de 
atualização de um produto, o método atualiza os valores que foram recebidos, filtrando o id
 do produto e do usuário, sendo que estes valores não podem ser atualizados;
Criar o método atualiza no controller de produto que responde ao método HTTP Put, que recebe 
como parâmetro de URL o id do produto a ser atualizado e como corpo da requisição os dados do 
produto com as validações já presentes no DTO. E assim haver o retorno ao final de uma mensagem 
que informa que o produto foi atualizado com sucesso, assim como os dados do produto;
Escrever o método remove no repositório, no qual, dado um id, busca o produto e o remove da 
lista de produtos, retornando ao final os dados do produto removido;
Escrever o método remove no controller de produtos que recebe como parâmetro de URL o id do 
produto e executa a remoção do produto, e retorna como resposta uma mensagem informando que o 
produto foi removido, assim como os dados do produto. Este método no controller deve responder
ao método DELETE do HTTP.

---------------------------------------------------------------------------------

 Um ponto importante na evolução de APIs Restful é como lidamos com a evolução 
 dessas APIs. Uma API precisa se manter estável quando em produção com clientes 
 fazendo uso de seus recursos. Diante disso, não é recomendável que simplesmente 
 removamos valores ou alteremos como determinado recurso funciona, pois os clientes 
 dessa API podem parar de funcionar de forma inesperada.

Claro, se é uma API privada, onde as alterações são negociadas entre as partes, 
este é um problema mais fácil de lidar. Mas em APIs públicas, como a do GitHub e 
outros serviços, essa é uma problemática para se ter cuidado.

Por isso, existem maneiras de lidar com essa evolução. Uma delas é o versionamento 
da API. Em casos em que determinado endpoint precise de mudanças, cria-se uma versão 
nova daquele mesmo endpoint onde essas mudanças serão aplicadas.

Este versionamento pode acontecer de algumas formas, a mais comum delas é a adição de 
um sub-caminho para o recurso, que especifica que versão está sendo usada daquela API. 
O exemplo abaixo ilustra melhor:

https://api.alura.com.br/v2/cursosCOPIAR CÓDIGO
O v2 presente na URL do endpoint indica a versão da API que estamos utilizando. Outra 
forma é usando query parameters, enviando também na URL, qual a versão da API que estamos 
usando:

https://api.alura.com.br/cursos?v=2COPIAR CÓDIGO
Por último, podemos usar cabeçalhos do HTTP para indicar para o servidor qual versão 
queremos usar da API. Normalmente, o cabeçalho usado é o Accept, mas pode ser um outro. 
O NestJS já possui um mecanismo que lida com o versionamento das APIs, facilitando a 
gestão desses endpoints.

Caso queira saber mais sobre as possibilidades de versionamento da API com Nestjs, a 
documentação possui uma página para explicar as formas suportadas por ele. Você pode 
ler mais neste link.

O que precisa ficar claro também é que conforme uma API evolui e publica mais versões 
de seus endpoints, mais complexo fica gerenciar a API em si. Cada endpoint evolui de 
forma independente, o que pode gerar situações onde um endpoint nunca precisou mudar, 
por isso, sempre esteve na sua versão original e outros endpoints que podem ter 3 ou 
4 versões diferentes.

---------------------------------------------------------------------------------

Em APIs Restful, você pode ter endpoints isolados, ou seja, lidam com as operações 
de CRUD de forma isolada sob um recurso só e endpoints que lidam com relacionamentos 
ou agregações.

Nos endpoints que lidam com relacionamentos/agregações, dependendo do tipo de 
relacionamento, a recomendação geral é que esse relacionamento seja expresso também nas 
URLs dos recursos.

Vejamos nosso exemplo da loja: Um usuário possui produtos. Sendo assim, os produtos 
da loja estão com um relacionamento forte com seus usuários. De fato, o usuário cria e 
remove produtos como bem entender. Sendo assim, a recomendação geral é que o CRUD de 
produtos tivesse endpoints relativos ao de usuários. O que isso quer dizer na prática? 
A URL a seguir demonstra a relação entre produtos e usuário:

http://localhost:3000/usuarios/1234/produtosCOPIAR CÓDIGO
O número 1234 na URL representa o usuário com aquele identificador. O /produtos logo 
após o identificador de usuário, representa o endpoint raiz de operações do CRUD para 
produtos daquele usuário. Considerando isso, teríamos o seguinte esquema de CRUD para 
produtos:

POST http://localhost:3000/usuarios/1234/produtos, para criar um produto;
GET http://localhost:3000/usuarios/1234/produtos, para listar todos os produtos;
PUT/PATCH http://localhost:3000/usuarios/1234/produtos/4321, para atualizar um produto;
DELETE http://localhost:3000/usuarios/1234/produtos, para remover um produto.
Durante nossas aulas, não seguimos este padrão para simplificar a construção geral da 
nossa loja. É importante ter isso em mente: não seguir uma recomendação ou um padrão 
precisa ser uma escolha consciente sobre os impactos dessa escolha.

---------------------------------------------------------------------------------

Usar o @PUT para atualizar um recurso na API.
Usar o @Delete para remover um recurso da API.
Criamos entidades para isolar objetos importantes do nosso contexto de negócio.
Usar o padrão DTO para isolar objetos de entrada e saída da nossa API.
Usar o @IsOptional para validar dados caso eles sejam enviados no corpo da requisição.

---------------------------------------------------------------------------------

Preparando o ambiente: configurando o Datasource

Para configurar o Datasource, o pré-requisito é apenas ter o typeORM e o 
módulo @nestjs/config já configurados. Com isso, basta seguir as instruções 
abaixo:

Na pasta src, crie uma pasta config e, dentro dela, crie um arquivo com o 
nome postgres.config.service.ts. Um detalhe interessante aqui é o seguinte: 
caso queira trabalhar com outro banco, é legal que o arquivo tenha o nome 
respectivo ao banco e/ou db.config.service.ts, que seria um nome genérico.

Feito isso, basta colar o conteúdo abaixo no arquivo criado anteriormente:

    import { Injectable } from '@nestjs/common';
    import { ConfigService } from '@nestjs/config';
    import { TypeOrmModuleOptions, TypeOrmOptionsFactory } from 
    '@nestjs/typeorm';
    
    @Injectable()
    export class PostgresConfigService implements TypeOrmOptionsFactory {
    
      constructor(private configService: ConfigService) {}
    
      createTypeOrmOptions(): TypeOrmModuleOptions {
        return {
          type: 'postgres',
          host: this.configService.get<string>('DB_HOST'),
          port: this.configService.get<number>('DB_PORT'),
          username: this.configService.get<string>('DB_USERNAME'),
          password: this.configService.get<string>('DB_PASSWORD'),
          database: this.configService.get<string>('DB_NAME'),
          entities: [],
          synchronize: true,
        };
      }
    }

Agora, precisamos que você instale a lib para conectar ao seu banco de 
dados. No curso, utilizamos o postgres, portanto, vamos adicioná-lo 
ao nosso projeto com o comando npm install pg.

    Caso queira utilizar outro banco, basta instalar o conector 
    relativo.

Na sequência, basta adicionar nos imports do arquivo app.module.ts o 
seguinte código:

   TypeOrmModule.forRootAsync({
     useClass: PostgresConfigService,
     inject: [PostgresConfigService]
   }),

O código acima também deve ser adicionado nos devidos imports 
relacionados - o nome da classe vai depender do nome do seu arquivo.

E, por último, não se esqueça de adicionar as variáveis no seu 
arquivo .env.

---------------------------------------------------------------------------------

 Preparando o ambiente: configurando o pgAdmin

 

Após executar o pgAdmin utilizando o docker-compose, você deve configurá-lo. 
Para isso, basta seguir os passos abaixo:

Acesse, no seu navegador, o endereço http://localhost:8081. Você deverá 
inserir o email e a senha que estão nas variáveis de ambiente DB_ADMIN_EMAIL 
e DB_PASSWORD, respectivamente, do arquivo .env.

Na sequência, você deve clicar em “Add New Server”, definir um nome e 
clicar em “Connection”.

Em “Connection”, basta colocar as seguintes informações:

    Host: postgres
    Porta: manter a 5432
    Username: root (ou o configurado no seu arquivo .env)
    Password: root (ou o configurado no seu arquivo .env)

Feito esses passos, basta salvar e acessar o novo servidor.

Em seguida, expanda as opções do servidor que você acabou de criar (no 
canto superior esquerdo) e clique com o botão direito em Databases.

Agora, basta criar o banco; estamos usando como db_loja o nome, porém, 
fica a seu critério.

Com o banco criado, você pode rodar novamente a sua aplicação com npm 
run start. Dessa vez, agora o Nest deve se conectar sem nenhum erro 
com o Postgres!

---------------------------------------------------------------------------------

Nesta aula, conhecemos um pouco sobre Datasource e alguns padrões de acesso ao 
dado. Entendemos que o Datasource é o banco de dados em si e que por meio dos 
padrões de acesso conseguimos acessar o dado propriamente dito.

Quais afirmações estão corretas?

O sistema pode trabalhar com vários Datasources.
É possível configurar vários Datasources em uma aplicação.
Alternativa correta

O padrão Repository traz um maior desacoplamento de regras.
Com o Repository Pattern conseguimos desacoplar as regras de acesso ao dado 
da entidade.

---------------------------------------------------------------------------------

O que é um Datasource e como nossa aplicação se comunica com o banco;
Quais bancos(MySQL, PostgreSQL, SQL Server, Oracle - para citar alguns) 
estão disponíveis dentro do TypeORM;
Padrões de acesso ao dado, algo extremamente importante para acessarmos o 
dado no banco dentro das melhores práticas.

---------------------------------------------------------------------------------

No vídeo anterior, indicamos o caminho das entidades para o Data Source do 
TypeORM no arquivo postgres.config.service.ts com o seguinte código:

entities: [__dirname + '/**/*.entity{.js,.ts}'],

Contudo, um ajuste precisa ser feito. Troque o código acima para o seguinte:

entities: [__dirname + '/../**/*.entity{.js,.ts}'],

Isso porque o __dirname indica o diretório atual no qual o arquivo 
postgres.config.service.ts se encontra, que é o config. Em seguida, na 
string que estamos concatenando, a notação .. irá subir para o diretório pai, 
que é o src. Depois, com a notação /**/*.entity{.js,.ts}, as entidades serão 
buscadas dentro de qualquer pasta que esteja dentro de src, e cada entidade é 
identificada como um arquivo que termina com .entity.js ou .entity.ts.

Com isso, o TypeORM irá encontrar os arquivos de entidades com sucesso!

Atenção: para os alunos que utilizam o Windows, existe um bug presente no 
TypeORM a partir da versão 0.3.12, que tem a ver com a resolução desses caminhos.

Para prevenir esse erro quando você fizer requisições para a API, você 
pode atualizar a versão do TypeORM do projeto com o seguinte comando:

npm install typeorm@0.3.11

A discussão desse bug pode ser encontrada nesse tópico do GitHub.

Caso você não queira alterar a versão do TyepORM no seu projeto, uma solução 
alternativa é importar diretamente as entidades na lista entities.

Outra solução para não ter esse bug é utilizar o WSL, já que no ambiente 
Ubuntu não há esse problema de resolução de caminhos.

---------------------------------------------------------------------------------

Nesta aula, visitamos e aplicamos os conceitos de entidade nas nossas classes 
pré-existentes. Entendemos que entidades são o "espelho" da nossa tabela.

Sobre entidades, quais são as alternativas corretas? 

A entidade representa o mapeamento relacional da tabela no código.
Em uma entidade eu tenho todos os campos e os respectivos tipos que os 
mesmos possuem no banco de dados.

Para que o projeto consiga acessar todos os campos da tabela, necessariamente 
esses campos precisam ser referenciados na entidade.
De fato, para que minha aplicação conheça todos os campos utilizando o conceito 
de ORM, é necessário que todos estejam mapeados na entidade.

Para que o TypeORM entenda o local que as entidades estão, é preciso 
referenciar no arquivo de configuração do Datasource.
Precisamos configurar no arquivo de config o caminho da nossa pasta onde 
estão as nossas entidades.

---------------------------------------------------------------------------------

O conceito de entidades, que representam o modelo da nossa tabela 
no nosso código;
A modelar as entidades que já tínhamos para adequar ao TypeORM.

---------------------------------------------------------------------------------

Nesta aula, conseguimos criar o nosso primeiro registro. E com isso, vimos na 
prática o uso do repositório e também dos nossos campos da entidade sendo 
preenchidos e persistidos no banco - uma vez que eles representam o nosso 
modelo relacional.

Dado esse cenário, entendemos que:

Com o TypeORM a inserção é totalmente abstraída, o que significa que eu 
não preciso escrever a instrução SQL.

Isso mesmo! Nesse caso de inserção (cenário comum), não é necessário a 
escrita da query SQL. 

---------------------------------------------------------------------------------

A implementar o padrão Repository para que nossa aplicação consiga persistir e 
buscar informações das nossas tabelas no nosso banco;
A implementar na prática o Repository Pattern, padrão que já tínhamos o 
conhecimento teórico.

---------------------------------------------------------------------------------

Nesta aula, aprendemos mais sobre relacionamentos e como aplicá-los utilizando 
o TypeORM. Entendemos que existem diversos tipos de relacionamentos e a sua 
aplicabilidade depende muito do cenário negocial. No nosso caso tivemos a 
ampla utilização do tipo 1:N, visto que produtos podem ter N características 
e/ou imagens.

A partir dos seus conhecimentos sobre TypeORM e relacionamentos, indique a 
afirmação correta:

O papel do Cascade é ter um controle na hierarquia dos relacionamentos - 
caso algum registro sofra alteração e/ou seja deletado, será aplicado 
em toda a cadeia.

Exatamente isso! Com o Cascade habilitado, toda a cadeia hierárquica 
terá alterações caso o registro principal sofra uma modificação.

---------------------------------------------------------------------------------

A integrar as nossas entidades para funcionar de acordo com o modelo negocial 
definido;
A aplicar o conceito de relacionamentos nas nossas entidades, identificando 
os tipos de relacionamentos, que são: 1 para 1, 1 para N(muitos) e N para 
N - muitos para muitos.

---------------------------------------------------------------------------------

Agora que você aprendeu sobre migrações, vamos aproveitar para realizar uma 
modificação no código e praticar esse conhecimento?

Abra o arquivo src/produto/produto.entity.ts. Nele, você encontrará a seguinte 
propriedade na entidade:

  @Column({ name: 'usuario_id', length: 100, nullable: false })
  usuarioId: string;

Contudo, essa propriedade não faz mais sentido para o contexto que vamos 
modelar nosso e-commerce. Ela estaria indicando, na teoria, que um produto 
referencia o ID de um usuário. Em outras palavras, um produto poderia estar 
associado a apenas um usuário. Além disso, aqui não estamos utilizando os 
decorators de relacionamentos do TypeORM (como o @ManyToOne e @OneToMany, 
então essa relação também não está corretamente estabelecida nas nossas 
entidades.

    Dando um spoiler: o que iremos modelar a partir da próxima aula é que 
    um usuário pode possuir vários pedidos. Os pedidos, por sua vez, podem 
    possuir vários produtos, ao mesmo tempo que um produto pode fazer parte 
    de vários pedidos. Assim, não haverá relação direta entre um usuário e 
    um produto. Você verá isso em mais detalhes com a Camis!

Dessa forma, remova essas duas linhas de código de ProdutoEntity. Como isso 
resultará em uma modificação no Banco de Dados, é importante que você gere 
e rode uma nova migração que reflita essa mudança.

---------------------------------------------------------------------------------

Existem alguns casos onde as queries SQL geradas pelas migrações podem causar 
erros ao serem executadas. Um exemplo é quando tentamos adicionar, em uma tabela, 
uma nova coluna que não permite valores nulos. Por exemplo, digamos que você 
queira adicionar uma coluna endereco em UsuarioEntity:

  @Column({ name: 'endereco', length: 255, nullable: false })
  endereco: string;

    Dica: na verdade, o parâmetro nullable é false por padrão no TypeORM, 
    então mesmo que você não passe essa propriedade, a coluna será criada 
    para não permitir valores nulos.

Suponha que você já tenha registros na tabela de usuários. Se você gerar uma 
migração para a alteração acima e tentar rodá-la, você verá um erro como o 
seguinte:

QueryFailedError: column "endereco" of relation "usuarios" contains null 
values

Traduzindo: A coluna "endereco" da relação "usuarios" contém valores nulos

E faz sentido que esse erro aconteça, pois se já houver ao menos um registro 
nessa tabela, eles não conseguirão definir automaticamente um valor para essa 
coluna ao tentar adicioná-la, já que ela não permite valores nulos.

    E caso não haja registros na tabela, a migração será executada sem erros. 
    Porém, ao tentar cadastrar um novo usuário, o TypeORM lançará um erro em 
    tempo de execução da API. Nesse caso, é importante reverter a migração com 
    migration:revert para retornar o Banco de Dados ao estado que estava 
    funcionando!

Dessa forma, temos duas opções. A primeira delas é permitir valores nulos 
nesta coluna, então basta definir o valor da propriedade nullable como true:

  @Column({ name: 'endereco', length: 255, nullable: true })
  endereco: string;

Neste caso, é importante ter em mente que nem todos os usuários terão um 
endereço em um primeiro momento. E isso faz sentido, já que até este momento 
essa informação não era exigida a todos os usuários.

A outra opção é manter a coluna como não nula e definir um valor padrão para 
ela com a propriedade default:

@Column({ name: 'endereco', length: 255, nullable: false, default: 'sem_endereco' })
endereco: string;

Para esse caso em específico, não é semântico utilizar uma string 'sem_endereco', 
então a primeira opção faz mais sentido. Contudo, há casos onde definir um valor 
padrão faz mais sentido do que permitir valores nulos, como o status de um pedido.

Ao escolher uma dessas soluções, você poderá gerar uma nova migração de acordo e 
executá-la. Caso você tenha um arquivo de migração no projeto que não foi 
executado e que você não precisa mais (como um que gera um erro), basta excluí-lo 
do projeto ou modificar suas queries SQL para realizar as operações adequadas 
para o seu caso.

Agora você entendeu melhor a causa de certos erros que podem acontecer ao rodar 
ou mesmo reverter migrações, dependendo das queries que foram geradas 
automaticamente pelo TypeORM. 

---------------------------------------------------------------------------------

Lisa é desenvolvedora e está trabalhando em um projeto que possui um Data Source 
configurado para a CLI do TypeORM, indicando corretamente os caminhos das 
entidades e o caminho das migrações no projeto.

O projeto já tem uma migração que constrói a estrutura inicial do Banco de 
Dados, criando uma tabela chamada filmes com as colunas nome e ano_lancamento. 
Lisa precisava adicionar uma coluna genero na tabela filmes no banco de dados, 
para isso ela incluiu a propriedade genero no código da entidade. O problema é 
que essa mudança ainda precisa ser refletida no banco de dados.

Quais comandos da CLI do TypeORM Lisa deve executar para que isso aconteça?

    migration:generate caminho-da-migracao/adiciona-coluna-genero-em-filmes
    migration:run.

Depois de modificar o código da entidade, o comando migration:generate identifica 
essa mudança e gera uma migração correspondente. Em seguida, o migration:run executa 
as migrações geradas que ainda não foram executadas, ou seja, ele irá executar a 
migração adiciona-coluna-genero-em-filmes e vai adicionar a coluna no banco de dados.

---------------------------------------------------------------------------------

Embarcar em um projeto em andamento que usa um BD:
    Você revisou as etapas necessárias que novos membros de um time devem 
    realizar obrigatoriamente: instalar as dependências, criar as variáveis 
    de ambiente, configurar o Docker e criar um servidor com um BD no 
    Postgres Admin.

Instalar a CLI do TypeORM e configurar um Data Source para ela:
    A CLI é necessária para trabalharmos com migrações no TypeORM.

Versionar o BD com migrações:
    Assim como o Git realiza o versionamento de código, as migrações realizam 
    o versionamento de Banco de Dados. Nós geramos e executamos uma migração 
    para cada nova alteração no BD que é realizada. As migrações contêm queries 
    SQL que aplicam uma alteração com o método up ou desfazem essa alteração 
    com o método down. Assim, é possível alternar facilmente entre diferentes 
    versões do Banco de Dados e sempre alinhar o time com a versão mais recente.

Utilizar os comandos para gerar, executar, reverter e mostrar migrações:
    Os comandos são migration:generate, migration:run, migration:revert e 
    migration:show. Para facilitar o uso, criamos o script "typeorm": 
    "typeorm-ts-node-esm --dataSource src/db/data-source-cli.ts".

---------------------------------------------------------------------------------

Antes de começarmos é preciso que o ambiente já esteja configurado. Vamos relembrar alguns passos importantes?

    Realize a configuração do ambiente de acordo com o Preparando Ambiente da aula 1;
    Verifique se as migrações já foram rodadas e criaram as versões no banco de dados. Você pode visualizar as tabelas acessando o localhost do seu PostgresAdmin;
    Caso as tabelas não tenham sido criadas, rode as migrações com comando npm run typeorm migration:run.

Depois disso, precisamos realizar a instalação de uma ferramenta importante, a CLI do Nest.js.

A CLI do Nest.js é uma interface de linha de comando que ajuda a inicializar, desenvolver e manter suas aplicações Nest.js. Essa ferramenta é útil de diferentes formas, inclusive possui uma técnica para a criação de camadas de visão e controle do CRUD automaticamente a partir do padrão arquitetural MVC , facilitando assim a manutenção do sistema. Esse recurso se chama scaffolding. Dessa forma, a CLI facilita o desenvolvimento de softwares a partir das boas práticas.

Utilizamos o comando a seguir para instalar a CLI do Nest.js globalmente:

---------------------------------------------------------------------------------

https://whimsical.com/der-ecommerce-compree-primeiro-474CA2Gwv6Me5URhCeEPc5

https://whimsical.com/der-ecommerce-compree-JgTNdk8pXrEXh8xSZSwgay

No vídeo anterior, você conferiu os Diagramas de Entidade e Relacionamento 
(DER) referentes ao projeto. Você pode acessá-los nos seguintes links:

    DER Compree Inicial;
    DER Compree com pedidos.

Um diagrama de entidade relacionamento reproduz, de forma gráfica ou visual, 
como as entidades ou tabelas de uma aplicação estarão vinculadas a um banco 
de dados. Criar essa representação visual facilita a compreensão de como 
estabelecer os relacionamentos 1:1 (um para um),1:N (um para muitos) e N:M 
(muitos para muitos). Para praticar você pode, inclusive, desenhar em um papel 
as tabelas e seus conectores.

Para simplificarmos ainda mais os relacionamentos, podemos descrevê-los em 
tópicos, como no exemplo a seguir:

Relação entre Usuário e Pedido

    Um Usuário pode ter vários Pedidos
    Cada Pedido pertence a apenas um Usuário (ou seja, um mesmo pedido não pode 
    pertencer a vários usuários)
    Assim, temos um Usuário para muitos Pedidos (1:N)

Relacionamento entre Pedido e Produto

    Um Pedido pode ter vários Produtos
    Um Produto pode pertencer a vários Pedidos
    Assim, temos muitos Pedidos para muitos Produtos

O assunto sobre relacionamentos e banco de dados é extenso e requer atenção, 
sugerimos que você leia o Artigo MER e DER: Definições, Banco de Dados e 
Exemplos, e também estude a Formação de Modelagem de dados.

---------------------------------------------------------------------------------

Uma das principais vantagens do Nest.js é a sua CLI, que oferece uma ampla 
gama de comandos para ajudar na criação e gerenciamento de sua aplicação. 
Um recurso especialmente útil é o CRUD generator, que traduzindo significa 
gerador de CRUD. Com o gerador CRUD, você pode criar rapidamente todas essas 
perações para um recurso específico do seu domínio, como usuários, produtos, 
pedidos, etc.

Para usar o gerador CRUD, você precisa ter o Nest.js e sua CLI instalados e 
configurados em seu ambiente de desenvolvimento. Em seguida, abra o terminal 
ou prompt de comando e navegue até o diretório do seu projeto. Agora você 
está pronto para executar o comando da CLI para criar o CRUD.

O comando para gerar o CRUD é o seguinte:

nest generate resource <nome-do-recurso>

Substitua <nome-do-recurso> pelo nome do recurso que você deseja criar. 
Por exemplo, se você quiser criar um CRUD para usuários, o comando seria:

nest generate resource users

Ao executar esse comando, a CLI do Nest.js criará automaticamente os 
arquivos necessários para o recurso de usuários. Isso inclui um controlador 
(controller), um serviço (service) e uma entidade (entity), se você estiver 
usando um banco de dados.

O controller é responsável por lidar com as requisições HTTP relacionadas 
ao recurso. Ele contém os métodos para criar, ler, atualizar e deletar os 
objetos do recurso. O Service é responsável pela lógica de negócio 
relacionada ao recurso, enquanto a Entity representa a estrutura de dados 
do recurso, se estiver usando um banco de dados.

Caso a CLI do Nest.js não atualize automaticamente o arquivo app.module.ts 
para importar o controlador e o serviço do recurso que você criou, é 
necessário importá-lo manualmente. Isso garante que o Nest.js reconheça e 
gerencie corretamente o novo recurso em sua aplicação.

Depois de executar o comando, você pode personalizar o código gerado de 
acordo com as necessidades do seu aplicativo. Por exemplo, você pode 
adicionar validações, personalizar as rotas ou adicionar relacionamentos 
com outras entidades.

Em resumo, a CLI do Nest.js é uma ferramenta poderosa que simplifica o 
processo de desenvolvimento de aplicativos com Nest.js. O recurso do 
gerador CRUD permite criar rapidamente operações básicas para recursos 
de domínio, economizando tempo e esforço. Utilize a CLI para acelerar o 
desenvolvimento e focar em aspectos mais complexos e personalizados de 
seus projetos.

---------------------------------------------------------------------------------



A padronização e convenção de nomenclatura de variáveis, funções, arquivos, 
dentre outros é uma boa prática que permite a consistência do código em projetos 
que apresentam diferentes níveis de complexidade.

Entretanto, a padronização em TypeScript, Nest.js ou no Banco de Dados não é a 
mesma e essas convenções diferentes aparecem com frequência em nosso projeto. 
É por esse motivo que algumas nomenclaturas no código parecem “variar” de 
padronização. Porém, o que ocorre é a utilização do padrão referente a cada 
ferramenta.

Vamos entender um pouco mais sobre isso?

Padrões de nomenclatura com TypeORM, PostgreSQL e Nest.js juntos

Há algumas convenções de nomenclatura específicas que são recomendadas para 
manter uma estrutura consistente e facilitar o desenvolvimento, como:

    Nomes de entidades no JavaScript: em geral, recomenda-se utilizar o padrão 
    PascalCase para nomear as entidades. Por exemplo, uma entidade para 
    representar um usuário pode ser chamada de User.
    Nomes das tabelas no banco de dados: alguns padrões podem ser utilizados, 
    mas nesse projeto optamos pelo plural e snake_case para representar o 
    conjunto de dados. Por exemplo, tabelas chamadas como usuarios, pedidos, 
    produtos, itens_pedidos etc.
    Nomes de colunas no JavaScript: utilize camelCase para nomear as colunas da 
    tabela do banco de dados. Por exemplo, uma coluna para armazenar o nome 
    completo de um usuário pode ser chamada de fullName.
    Nomes de colunas no banco de dados: já para as colunas, a convenção é
     utilizar o singular e snake_case. Por exemplo: nome, descricao, valor, 
     quantidade_disponivel etc.
    Chaves primárias (primary key): recomenda-se utilizar o nome id para a 
    chave primária das entidades. O TypeORM identifica automaticamente a 
    coluna id como chave primária, mas também permite definir outros nomes 
    se necessário.
    Chaves estrangeiras (foreign key): para as chaves estrangeiras, é comum 
    adicionar o nome da entidade relacionada, seguido de Id. Por exemplo, se 
    uma entidade Pedido possui uma relação com a entidade Usuario, a coluna 
    de chave estrangeira pode ser chamada de usuarioId.
    Relações (relation): para estabelecer relações entre entidades no TypeORM, 
    é possível usar decorators como @ManyToOne, @OneToMany, entre outros. Ao 
    utilizar esses decorators, é recomendado utilizar o nome da entidade no 
    singular para definir a relação. Por exemplo, se uma entidade Usuario 
    possui vários pedidos, a relação pode ser definida como @OneToMany(() => 
    Pedidos, pedido => pedido.usuario).

Essas são apenas algumas das convenções mais comuns ao usar o TypeORM com o 
PostgreSQL e o Nest.js. No entanto, é importante ressaltar que essas 
convenções podem ser adaptadas de acordo com as necessidades específicas 
do projeto e das diretrizes da equipe, ou seja, as convenções podem variar 
dependendo do padrão adotado pela equipe ou organização, e é essencial manter
 a consistência dentro do projeto para facilitar a leitura e manutenção do código.

---------------------------------------------------------------------------------



---------------------------------------------------------------------------------